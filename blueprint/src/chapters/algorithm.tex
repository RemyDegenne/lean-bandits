\chapter{Iterative stochastic algorithms}


Warning: all times start at zero.

TODO: notations

All measurable spaces are assumed to be standard Borel.


\inputleannode{def:algorithm}

After the algorithm takes an action, the environment generates an observation according to a Markov kernel $\nu_t : (\mathcal{A} \times \mathcal{R})^{t+1} \times \mathcal{A} \rightsquigarrow \mathcal{R}$.


\inputleannode{def:environment}


\inputleannode{def:detAlgorithm}


\inputleannode{def:stationaryEnv}

TODO: possibly change the ``stationary'' name.


Let's detail four examples of interactions between an algorithm and an environment.
\begin{enumerate}
  \item \textbf{First order optimization}. The objective of the algorithm is to find the minimum of a function $f : \mathbb{R}^d \to \mathbb{R}$.
  The action space is $\mathcal{A} = \mathbb{R}^d$ (a point on which the function will be queried) and the observation space is $\mathcal{R} = \mathbb{R} \times \mathbb{R}^d$.
  The environment is described by a function $g : \mathbb{R}^d \to \mathbb{R} \times \mathbb{R}^d$ such that for all $x \in \mathbb{R}^d$, $g(x) = (f(x), \nabla f(x))$. That is, the kernel $\nu_t$ is deterministic and depends only on the action: it is given by $\nu_t(h_t, x) = \delta_{g(x)}$ (the Dirac measure at $g(x)$).
  An example of algorithm is gradient descent with fixed step size $\eta > 0$: this is a deterministic algorithm defined by $P_0 = \delta_{x_0}$ for some initial point $x_0 \in \mathbb{R}^d$ and for all $t \in \mathbb{N}$, $\pi_t(h_t) = \delta_{x_{t+1}}$ where $x_{t+1} = x_t - \eta \nabla g_2(x_t)$.

  \item \textbf{Stochastic bandits}. The action space is $\mathcal{A} = [K]$ for some $K \in \mathbb{N}$ (the set of arms) and the observation space is $\mathcal{R} = \mathbb{R}$ (the reward obtained after pulling an arm).
  The kernel $\nu_t$ is stationary and depends only on the action: there are probability distributions $(P_a)_{a \in [K]}$ such that for all $t \in \mathbb{N}$, for all $h_t \in (\mathcal{A} \times \mathcal{R})^{t+1}$, for all $a \in \mathcal{A}$, $\nu_t(h_t, a) = P_a$.

  \item \textbf{Adversarial bandits}. The action space is $\mathcal{A} = [K]$ for some $K \in \mathbb{N}$ (the set of arms) and the observation space is $\mathcal{R} = \mathbb{R}$ (the reward obtained after pulling an arm).
  The reward kernels are usually taken to be deterministic and in an \emph{oblivious} adversarial bandit they depend only on the time step: there is a sequence of vectors $(r_t)_{t \in \mathbb{N}}$ in $[0,1]^K$ such that for all $t \in \mathbb{N}$, for all $h_t \in (\mathcal{A} \times \mathcal{R})^{t+1}$, for all $a \in \mathcal{A}$, $\nu_t(h_t, a) = \delta_{r_{t,a}}$ (the Dirac measure at $r_{t,a}$).

  \item \textbf{Reinforcement learning in Markov decision processes}.
  TODO: main feature is that $\mathcal{R} = \mathcal{S} \times \mathbb{R}$ where $\mathcal{S}$ is the state space, and the kernel $\nu_t$ depends on the last state only.
\end{enumerate}


We will want to make global probabilistic statements about the whole sequence of actions and observations.
For example, we may want to prove that an optimization algorithm converges to the minimum of a function almost surely.
For such a statement to make sense, we need a probability space on which the whole sequence of actions and observations is defined as a random variable.

We denote by $P[X \mid Y]$ the conditional distribution of a random variable $X$ given another random variable $Y$ under a probability measure $P$.
When we write that $P[X \mid Y] = \kappa$, or that $X$ has conditional distribution $\kappa$ given $Y$, the equality should be understood as holding $Y_* P$-almost surely.


\inputleannode{def:IsAlgEnvSeq}


\inputleannode{def:history}


\inputleannode{lem:law_step}




\inputleannode{def:IsAlgEnvSeq.filtration}


\inputleannode{thm:isAlgEnvSeq_unique}





\section{Stationary environment}

Recall that in a stationary environment, there exists a Markov kernel $\nu : \mathcal{A} \rightsquigarrow \mathcal{R}$ such that $\nu'_0 = \nu$ and for all $t \in \mathbb{N}$, for all $h_t \in (\mathcal{A} \times \mathcal{R})^{t+1}$, for all $a \in \mathcal{A}$, $\nu_t(h_t, a) = \nu(a)$.

Let $(A, R, P)$ be an algorithm-environment interaction in a stationary environment with kernel $\nu$.

\inputleannode{lem:condDistrib_reward_stationaryEnv}




\inputleannode{lem:condIndepFun_reward_hist_action}





\section{Probability space: Ionescu-Tulcea theorem}

In Theorem~\ref{thm:isAlgEnvSeq_unique}, we saw that the distribution of the sequence of actions and observations in a suitable probability space is uniquely determined by the algorithm and the environment.
We now show that such a probability space actually exists: for any algorithm and environment, we build an algorithm-environment interaction as in Definition~\ref{def:IsAlgEnvSeq}.



\subsection{Ionescu-Tulcea theorem}

If we group together the policy of the algorithm and the kernel of the environment at each time step, we get a sequence of Markov kernels $(\kappa_t)_{t \in \mathbb{N}}$, with $\kappa_t : (\mathcal{A} \times \mathcal{R})^{t+1}  \rightsquigarrow (\mathcal{A} \times \mathcal{R})$.


We now abstract that situation and consider a sequence of measurable spaces $(\Omega_t)_{t \in \mathbb{N}}$, a probability measure $\mu$ on $\Omega_0$ and a sequence of Markov kernels $\kappa_t : \prod_{s=0}^t \Omega_s \rightsquigarrow \Omega_{t+1}$.
The Ionescu-Tulcea theorem builds a probability space from the sequence of kernels and the initial measure.


\inputleannode{thm:ionescu-tulcea}



The Ionescu-Tulcea theorem in Mathlib \cite{marion2025formalization} actually generates kernels $\xi_t : \prod_{s=0}^t \Omega_s \rightsquigarrow \prod_{s=0}^{\infty} \Omega_s$ for any $t$, with the property that the kernels are the identity on the first $t+1$ coordinates.

\inputleannode{def:trajMeasure}


\inputleannode{def:IT.history}

Note: $(X_t)_{t \in \mathbb{N}}$ is the canonical process on $\Omega_{\mathcal{T}}$. $H_t$ is equal to $\pi_{[0,t]}$.


\inputleannode{def:IT.filtration}

$(\mathcal{F}_t)_{t \in \mathbb{N}}$ is the canonical filtration on $\Omega_{\mathcal{T}}$, and is the natural filtration for the canonical process $(X_t)_{t \in \mathbb{N}}$.


\inputleannode{lem:IT.adapted_history}




\inputleannode{lem:IT.condDistrib_X_add_one}




\inputleannode{lem:law_step}






\subsection{Case of an algorithm-environment interaction}

We now go back to the setting of an algorithm interacting with an environment and suppose that $\Omega_t = \mathcal{A} \times \mathcal{R}$ for some measurable spaces $\mathcal{A}$ and $\mathcal{R}$, and that for all $t \in \mathbb{N}$, $\kappa_t = \pi_t \otimes \nu_t$ for policy kernels $\pi_t : (\mathcal{A} \times \mathcal{R})^{t+1} \rightsquigarrow \mathcal{A}$ and feedback kernels $\nu_t : (\mathcal{A} \times \mathcal{R})^{t+1} \times \mathcal{A} \rightsquigarrow \mathcal{R}$.
Likewise, $\mu = P_0 \otimes \nu'_0$ for a probability measure $P_0$ on $\mathcal{A}$ and a Markov kernel $\nu'_0 : \mathcal{A} \rightsquigarrow \mathcal{R}$.
The step random variable $X_t$ takes values in $\mathcal{A} \times \mathcal{R}$.

\inputleannode{def:IT.actionReward}


\inputleannode{lem:IT.adapted_action_reward}




We need to check that the random variables $A_t$ and $R_t$ have the expected conditional distributions.

\inputleannode{lem:IT.condDistrib_A_add_one}




\inputleannode{lem:IT.condDistrib_R_add_one}




\inputleannode{lem:IT.law_A_zero}




\inputleannode{lem:IT.condDistrib_R_zero}




\inputleannode{thm:isAlgEnvSeq_trajMeasure}





\section{Finitely many actions}

When the number of actions is finite, it makes sense to count how many times each action was chosen up to a certain time.
We can also define the time step at which an action was chosen a certain number of times, and the value of the reward obtained when pulling an action for the $m$-th time.

\inputleannode{def:pullCount}

Note that the sum goes up to $t-1$, so that $N_{t,a}$ counts the number of times action $a$ was chosen \emph{before} time $t$.


\begin{remark}[Building vs analyzing algorithms]
When we describe an algorithm, we give the data of the policies $\pi_t$, which are functions of the partial history up to time $t$, in $(\mathcal{A} \times \mathcal{R})^{t+1}$.
That means that any tool used to define a policy must be a function defined on $(\mathcal{A} \times \mathcal{R})^{t+1}$.
For example a definition of the empirical mean of an action must be a function $t : \mathbb{N} \to (\mathcal{A} \times \mathcal{R})^{t+1} \to \mathbb{R}$.

When we analyze an algorithm, we work on the other hand on a probability space $(\Omega, P)$, in which $\Omega$ could be for example $(\mathcal{A} \times \mathcal{R})^{\mathbb{N}}$, the full history, which describes the whole sequence of actions and rewards.
As a stochastic process, the empirical mean of an action is a function $\mathbb{N} \to (\mathcal{A} \times \mathcal{R})^{\mathbb{N}} \to \mathbb{R}$.

Thus there are two similar but still distinct types of objects: those defined on the partial history, which are used to build algorithms, and those defined on a generic probability space (the full history in the Ionescu-Tulcea construction), which are used to analyze algorithms.
\end{remark}


\inputleannode{lem:pullCount_basic}




\inputleannode{lem:predictable_pullCount}




\inputleannode{def:stepsUntil}

By definition, $T_{n, a}$ is the hitting time of the set $\{n\}$ by the process $t \mapsto N_{t+1,a}$, which is adapted since $N_{t,a}$ is predictable.
Equivalently, $T_{n, a}$ is the hitting time of the set $[n, +\infty]$ by that process.


\inputleannode{lem:stepsUntil_basic}




\inputleannode{lem:isStoppingTime_stepsUntil}




Let $\Omega' = \mathcal{R}^{\mathbb{N} \times \mathcal{A}}$ and let $\Omega = \Omega_{\mathcal{T}} \times \Omega'$ (which will be an extension of the trajectory probability space once we choose a measure on $\Omega'$).
Let $Z_{n, a} : \Omega \to \mathcal{R}$ be the projection on the coordinate indexed by $(n,a)$ in $\Omega'$.
Extending the probability space in that way allows us to define without ambiguity the reward received when choosing an action for the $n$-th time, even if that action is never actually chosen $n$ times.


\inputleannode{def:rewardByCount}


\inputleannode{lem:rewardByCount_pullCount}




% \begin{lemma}\label{lem:measurable_rewardByCount_mul_indicator}
%   \uses{def:rewardByCount, def:stepsUntil}
% $Y_{n, a} \mathbb{I}\{T_{n, a} < \infty\}$ is $\mathcal{F}_{T_{n, a}}$-measurable.
% \end{lemma}

% \begin{proof}
% It is the stopped value of the adapted process $(R_t)_{t \in \mathbb{N}}$ at the stopping time $T_{n, a}$.
% \end{proof}


\section{Scalar rewards}

TODO: change the name ``reward'' to ``observation'' throughout the chapter?

We now focus on the case where the reward space is $\mathcal{R} = \mathbb{R}$.


\inputleannode{def:sumRewards}


\inputleannode{def:empMean}

Note: in bandit papers it is common to (implicitly) define the empirical mean as $+\infty$ when the action was never chosen, but in Lean it has to be a real number, and the Lean default value for division by zero is $0$.


The following lemma is very useful to relate the two ways of indexing the rewards: by time step and by pull count.

\inputleannode{lem:sum_rewardByCount}


