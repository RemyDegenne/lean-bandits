/-
Copyright (c) 2025 RÃ©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: RÃ©my Degenne, Paulo Rauber
-/
import LeanBandits.ForMathlib.CondIndepFun
import LeanBandits.ForMathlib.IndepInfinitePi
import LeanBandits.ForMathlib.KernelRepresentation
import LeanBandits.SequentialLearning.Deterministic
import LeanBandits.SequentialLearning.StationaryEnv
import LeanBandits.SequentialLearning.FiniteActions
import Mathlib.Probability.IdentDistrib
import Mathlib.MeasureTheory.Constructions.UnitInterval

/-!
# Bandit
-/

open MeasureTheory ProbabilityTheory Filter Real Finset Learning

open scoped ENNReal NNReal

namespace Bandits

variable {Î± R : Type*} {mÎ± : MeasurableSpace Î±} {mR : MeasurableSpace R}

section MeasureSpace

namespace Bandit

/-- Kernel describing the distribution of the next action-reward pair given the history up to
time `n`. -/
noncomputable
def stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    Kernel (Iic n â†’ Î± Ã— R) (Î± Ã— R) :=
  Learning.stepKernel alg (stationaryEnv Î½) n
deriving IsMarkovKernel

@[simp]
lemma fst_stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (stepKernel alg Î½ n).fst = alg.policy n := by
  rw [stepKernel, Learning.fst_stepKernel]

@[simp]
lemma snd_stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (stepKernel alg Î½ n).snd = Î½ âˆ˜â‚– alg.policy n := by
  rw [stepKernel, Learning.stepKernel, stationaryEnv_feedback, Kernel.snd_compProd_prodMkLeft]

/-- Measure on the sequence of actions pulled and rewards observed generated by the bandit. -/
noncomputable
def trajMeasure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : Measure (â„• â†’ Î± Ã— R) :=
  Learning.trajMeasure alg (stationaryEnv Î½)
deriving IsProbabilityMeasure

/-- Measure of an infinite stream of rewards from each action. -/
noncomputable
def streamMeasure (Î½ : Kernel Î± R) : Measure (â„• â†’ Î± â†’ R) :=
  Measure.infinitePi fun _ â†¦ Measure.infinitePi Î½

instance (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : IsProbabilityMeasure (streamMeasure Î½) := by
  unfold streamMeasure
  infer_instance

/-- Joint distribution of the sequence of action pulled and rewards, and a stream of independent
rewards from all actions. -/
noncomputable
def measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    Measure ((â„• â†’ Î± Ã— R) Ã— (â„• â†’ Î± â†’ R)) :=
  (trajMeasure alg Î½).prod (streamMeasure Î½)
deriving IsProbabilityMeasure

@[simp]
lemma fst_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    (measure alg Î½).fst = trajMeasure alg Î½ := by
  rw [measure, Measure.fst_prod]

@[simp]
lemma snd_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    (measure alg Î½).snd = streamMeasure Î½ := by
  rw [measure, Measure.snd_prod]

end Bandit

section StreamMeasure

lemma _root_.hasLaw_eval_infinitePi {Î¹ : Type*} {X : Î¹ â†’ Type*} {mX : âˆ€ i, MeasurableSpace (X i)}
  (Î¼ : (i : Î¹) â†’ Measure (X i)) [hÎ¼ : âˆ€ i, IsProbabilityMeasure (Î¼ i)] (i : Î¹) :
    HasLaw (Function.eval i) (Î¼ i) (Measure.infinitePi Î¼) where
  aemeasurable := Measurable.aemeasurable (by fun_prop)
  map_eq := by exact (measurePreserving_eval_infinitePi Î¼ i).map_eq

lemma hasLaw_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasLaw (fun h : â„• â†’ Î± â†’ R â†¦ h n) (Measure.infinitePi Î½) (Bandit.streamMeasure Î½) :=
  hasLaw_eval_infinitePi (fun _ â†¦ Measure.infinitePi Î½) n

lemma hasLaw_eval_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    HasLaw (fun h : â„• â†’ Î± â†’ R â†¦ h n a) (Î½ a) (Bandit.streamMeasure Î½) :=
  (hasLaw_eval_infinitePi Î½ a).comp (hasLaw_eval_streamMeasure Î½ n)

lemma identDistrib_eval_eval_id_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    IdentDistrib (fun h : â„• â†’ Î± â†’ R â†¦ h n a) id (Bandit.streamMeasure Î½) (Î½ a) where
  aemeasurable_fst := Measurable.aemeasurable (by fun_prop)
  aemeasurable_snd := Measurable.aemeasurable (by fun_prop)
  map_eq := by
    rw [â† (hasLaw_eval_eval_streamMeasure Î½ n a).map_eq,
      Measure.map_map (by fun_prop) (by fun_prop)]
    simp

lemma Integrable.congr_identDistrib {Î© Î©' : Type*}
    {mÎ© : MeasurableSpace Î©} {mÎ©' : MeasurableSpace Î©'}
    {Î¼ : Measure Î©} {Î¼' : Measure Î©'} {X : Î© â†’ â„} {Y : Î©' â†’ â„}
    (hX : Integrable X Î¼) (hXY : IdentDistrib X Y Î¼ Î¼') :
    Integrable Y Î¼' := by
  have hX' : Integrable id (Î¼.map X) := by
    rwa [integrable_map_measure (by fun_prop) hXY.aemeasurable_fst]
  rw [hXY.map_eq] at hX'
  rwa [integrable_map_measure (by fun_prop) hXY.aemeasurable_snd] at hX'

lemma integrable_eval_streamMeasure (Î½ : Kernel Î± â„) [IsMarkovKernel Î½] (n : â„•) (a : Î±)
    (h_int : Integrable id (Î½ a)) :
    Integrable (fun h : â„• â†’ Î± â†’ â„ â†¦ h n a) (Bandit.streamMeasure Î½) :=
  Integrable.congr_identDistrib h_int (identDistrib_eval_eval_id_streamMeasure Î½ n a).symm

lemma integral_eval_streamMeasure (Î½ : Kernel Î± â„) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    âˆ« h, h n a âˆ‚(Bandit.streamMeasure Î½) = (Î½ a)[id] := by
  calc âˆ« h, h n a âˆ‚(Bandit.streamMeasure Î½)
  _ = âˆ« x, x âˆ‚((Bandit.streamMeasure Î½).map (fun h â†¦ h n a)) := by
    rw [integral_map (Measurable.aemeasurable (by fun_prop)) (by fun_prop)]
  _ = (Î½ a)[id] := by simp [(hasLaw_eval_eval_streamMeasure Î½ n a).map_eq]

lemma iIndepFun_eval_streamMeasure' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    iIndepFun (fun n Ï‰ â†¦ Ï‰ n) (Bandit.streamMeasure Î½) :=
  iIndepFun_infinitePi (P := fun (_ : â„•) â†¦ Measure.infinitePi Î½) (Î© := fun _ â†¦ Î± â†’ R)
    (X := fun i u â†¦ u) (fun i â†¦ by fun_prop)

lemma iIndepFun_eval_streamMeasure'' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) :
    iIndepFun (fun n Ï‰ â†¦ Ï‰ n a) (Bandit.streamMeasure Î½) :=
  (iIndepFun_eval_streamMeasure' Î½).comp (g := fun i Ï‰ â†¦ Ï‰ a) (by fun_prop)

lemma iIndepFun_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    iIndepFun (fun (p : â„• Ã— Î±) Ï‰ â†¦ Ï‰ p.1 p.2) (Bandit.streamMeasure Î½) :=
  iIndepFun_uncurry_infinitePi' (X := fun _ _ â†¦ id) (fun _ â†¦ Î½) (by fun_prop)

lemma indepFun_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] {n m : â„•} {a b : Î±}
    (h : n â‰  m âˆ¨ a â‰  b) :
    IndepFun (fun Ï‰ â†¦ Ï‰ n a) (fun Ï‰ â†¦ Ï‰ m b) (Bandit.streamMeasure Î½) := by
  change IndepFun (fun Ï‰ â†¦ Ï‰ (n, a).1 (n, a).2) (fun Ï‰ â†¦ Ï‰ (m, b).1 (m, b).2)
    (Bandit.streamMeasure Î½)
  exact (iIndepFun_eval_streamMeasure Î½).indepFun (by grind)

lemma indepFun_eval_streamMeasure' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] {a b : Î±} (h : a â‰  b) :
    IndepFun (fun Ï‰ n â†¦ Ï‰ n a) (fun Ï‰ n â†¦ Ï‰ n b) (Bandit.streamMeasure Î½) :=
  indepFun_proj_infinitePi_infinitePi h

lemma indepFun_eval_snd_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    {a b : Î±} (h : a â‰  b) :
    IndepFun (fun Ï‰ n â†¦ Ï‰.2 n a) (fun Ï‰ n â†¦ Ï‰.2 n b) (Bandit.measure alg Î½) := by
  refine indepFun_snd_prod ?_ ?_ (indepFun_eval_streamMeasure' Î½ h) (Bandit.trajMeasure alg Î½)
  Â· exact Measurable.aemeasurable (by fun_prop)
  Â· exact Measurable.aemeasurable (by fun_prop)

end StreamMeasure

section DetAlgorithm

variable {nextaction : (n : â„•) â†’ (Iic n â†’ Î± Ã— R) â†’ Î±} {h_next : âˆ€ n, Measurable (nextaction n)}
  {action0 : Î±} {Î½ : Kernel Î± R} [IsMarkovKernel Î½]

local notation "ğ”“t" => Bandit.trajMeasure (detAlgorithm nextaction h_next action0) Î½

lemma HasLaw_action_zero_detAlgorithm : HasLaw (IT.action 0) (Measure.dirac action0) ğ”“t where
  map_eq := (IT.hasLaw_action_zero _ _).map_eq

lemma action_zero_detAlgorithm [MeasurableSingletonClass Î±] :
    IT.action 0 =áµ[ğ”“t] fun _ â†¦ action0 :=
  IT.action_zero_detAlgorithm

lemma action_detAlgorithm_ae_eq [StandardBorelSpace Î±] [Nonempty Î±]
    [StandardBorelSpace R] [Nonempty R] (n : â„•) :
    IT.action (n + 1) =áµ[ğ”“t] fun h â†¦ nextaction n (fun i â†¦ h i) :=
  IT.action_detAlgorithm_ae_eq n

example [StandardBorelSpace Î±] [Nonempty Î±]
    [StandardBorelSpace R] [Nonempty R] :
    âˆ€áµ h âˆ‚(ğ”“t), IT.action 0 h = action0 âˆ§
      âˆ€ n, IT.action (n + 1) h = nextaction n (fun i â†¦ h i) := by
  rw [eventually_and, ae_all_iff]
  exact âŸ¨action_zero_detAlgorithm, action_detAlgorithm_ae_eqâŸ©

end DetAlgorithm

namespace ArrayModel

open unitInterval

section Aux

theorem representation_measure {Î² : Type*} {mÎ² : MeasurableSpace Î²}
    [Nonempty Î²] [StandardBorelSpace Î²]
    (Î¼ : Measure Î²) [IsProbabilityMeasure Î¼] :
    âˆƒ (f : I â†’ Î²), Measurable f âˆ§ volume.map f = Î¼ := by
  obtain âŸ¨f, hf_meas, hf_mapâŸ© := Kernel.representation (Kernel.const Unit Î¼)
  specialize hf_map âŸ¨âŸ©
  exact âŸ¨f âŸ¨âŸ©, by fun_prop, by simpaâŸ©

end Aux

variable (Î± R) in
def probSpace : Type _ := (â„• â†’ I) Ã— (â„• â†’ Î± â†’ R)

instance {Î± R : Type*} [MeasurableSpace R] : MeasurableSpace (probSpace Î± R) :=
  inferInstanceAs (MeasurableSpace ((â„• â†’ I) Ã— (â„• â†’ Î± â†’ R)))

instance {Î± R : Type*} [MeasurableSpace Î±] [Countable Î±]
    [MeasurableSpace R] [StandardBorelSpace R] [Nonempty R] :
    StandardBorelSpace (probSpace Î± R) := by
  unfold probSpace
  infer_instance

noncomputable
def arrayMeasure (Î½ : Kernel Î± R) : Measure (probSpace Î± R) :=
  (Measure.infinitePi fun _ â†¦ volume).prod (Bandit.streamMeasure Î½)

instance (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : IsProbabilityMeasure (arrayMeasure Î½) :=
  Measure.prod.instIsProbabilityMeasure _ _

variable [Nonempty Î±] [StandardBorelSpace Î±]

noncomputable
def initAlgFunction (alg : Algorithm Î± R) : I â†’ Î± :=
  (representation_measure alg.p0).choose

lemma initAlgFunction_map (alg : Algorithm Î± R) : volume.map (initAlgFunction alg) = alg.p0 :=
  (representation_measure alg.p0).choose_spec.2

@[fun_prop]
lemma measurable_initAlgFunction (alg : Algorithm Î± R) :
    Measurable (initAlgFunction alg) := (representation_measure alg.p0).choose_spec.1

noncomputable
def algFunction (alg : Algorithm Î± R) (n : â„•) :
    (Iic n â†’ Î± Ã— R) â†’ I â†’ Î± :=
  (Kernel.representation (alg.policy n)).choose

lemma algFunction_map (alg : Algorithm Î± R) (n : â„•) (h : Iic n â†’ Î± Ã— R) :
      volume.map (algFunction alg n h) = alg.policy n h :=
  (Kernel.representation (alg.policy n)).choose_spec.2 h

@[fun_prop]
lemma measurable_algFunction (alg : Algorithm Î± R) (n : â„•) :
    Measurable (Function.uncurry (algFunction alg n)) :=
  (Kernel.representation (alg.policy n)).choose_spec.1

noncomputable
def hist [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) : (n : â„•) â†’ Iic n â†’ Î± Ã— R
| 0 => fun _ â†¦ (initAlgFunction alg (Ï‰.1 0), Ï‰.2 0 (initAlgFunction alg (Ï‰.1 0)))
| n + 1 =>
  let hn : Iic n â†’ Î± Ã— R := hist alg Ï‰ n
  let a : Î± := algFunction alg n hn (Ï‰.1 (n + 1))
  fun i â†¦ if hin : i â‰¤ n then hn âŸ¨i, by simp [hin]âŸ© else (a, Ï‰.2 (pullCount' n hn a) a)

@[simp]
lemma hist_zero [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) :
    hist alg Ï‰ 0 = fun _ â†¦ (initAlgFunction alg (Ï‰.1 0), Ï‰.2 0 (initAlgFunction alg (Ï‰.1 0))) :=
  rfl

lemma hist_add_one [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) (n : â„•) :
    let a : Î± := algFunction alg n (hist alg Ï‰ n) (Ï‰.1 (n + 1))
    hist alg Ï‰ (n + 1) =
      fun (i : Iic (n + 1)) â†¦ if hin : i â‰¤ n then hist alg Ï‰ n âŸ¨i, by simp [hin]âŸ©
        else (a, Ï‰.2 (pullCount' n (hist alg Ï‰ n) a) a) :=
  rfl

lemma hist_eq [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) (n : â„•) :
    hist alg Ï‰ n = fun i : Iic n â†¦ hist alg Ï‰ i âŸ¨i.1, by simpâŸ© := by
  induction n with
  | zero =>
    ext i : 1
    simp only [hist]
    rw [Unique.eq_default i]
    simp [coe_default_Iic_zero]
  | succ n hn =>
    ext i : 1
    by_cases hin : i â‰¤ n
    Â· rw [hist_add_one]
      simp only [hin, â†“reduceDIte]
      rw [funext_iff] at hn
      simp_rw [hn]
    Â· grind

lemma hist_add_one_eq_IicSuccProd' [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R)
    (n : â„•) :
    let a : Î± := algFunction alg n (hist alg Ï‰ n) (Ï‰.1 (n + 1))
    hist alg Ï‰ (n + 1) =
      (MeasurableEquiv.IicSuccProd (fun _ â†¦ Î± Ã— R) n).symm
        (hist alg Ï‰ n, (a, Ï‰.2 (pullCount' n (hist alg Ï‰ n) a) a)) := by
  intro a
  rw [hist_add_one]
  ext i : 1
  simp only [Kernel.symm_IicSuccProd, MeasurableEquiv.prodCongr, MeasurableEquiv.refl_toEquiv,
    MeasurableEquiv.piSingleton, eq_rec_constant, MeasurableEquiv.IicProdIoc,
    MeasurableEquiv.trans_apply, MeasurableEquiv.coe_mk, Equiv.prodCongr_apply, Equiv.coe_refl,
    Equiv.coe_fn_mk, Prod.map_apply, id_eq]
  rfl

lemma measurable_action_add_one' [DecidableEq Î±] {alg : Algorithm Î± R}
    (n : â„•) (h : Measurable (hist alg Â· n)) :
    Measurable (fun x â†¦ algFunction alg n (hist alg x n) (x.1 (n + 1))) := by fun_prop

instance : MeasurableEq Î± := by
  letI := upgradeStandardBorel Î±
  infer_instance

lemma measurable_pullCount'_action_add_one [DecidableEq Î±] {alg : Algorithm Î± R}
    (n : â„•) (h_hist : Measurable (hist alg Â· n)) :
    Measurable (fun x â†¦
      pullCount' n (hist alg x n) (algFunction alg n (hist alg x n) (x.1 (n + 1)))) := by
  have h_alg_meas : Measurable (fun x â†¦ algFunction alg n (hist alg x n) (x.1 (n + 1))) :=
    measurable_action_add_one' n h_hist
  exact (measurable_uncurry_pullCount' (Î± := Î±) n).comp (h_hist.prodMk h_alg_meas)

@[fun_prop]
lemma measurable_hist [DecidableEq Î±] [Countable Î±] (alg : Algorithm Î± R) (n : â„•) :
    Measurable (fun Ï‰ â†¦ hist alg Ï‰ n) := by
  induction n with
  | zero =>
    simp_rw [hist_zero, measurable_pi_iff]
    refine fun _ â†¦ Measurable.prodMk (by fun_prop) ?_
    change Measurable ((fun x : Î± Ã— ((â„• â†’ I) Ã— (â„• â†’ Î± â†’ R)) â†¦ x.2.2 0 x.1) âˆ˜
        (fun x : (â„• â†’ I) Ã— (â„• â†’ Î± â†’ R) â†¦ (initAlgFunction alg (x.1 0), x)))
    have : Measurable (fun x : Î± Ã— ((â„• â†’ I) Ã— (â„• â†’ Î± â†’ R)) â†¦ x.2.2 0 x.1) :=
      measurable_from_prod_countable_right fun p â†¦ by simp only; fun_prop
    exact Measurable.comp (by fun_prop) (Measurable.prodMk (by fun_prop) (by fun_prop))
  | succ n hn =>
    refine measurable_pi_iff.mpr fun i â†¦ ?_
    by_cases hin : i â‰¤ n
    Â· simp only [hist, hin, â†“reduceDIte]
      rw [measurable_pi_iff] at hn
      exact hn âŸ¨i.1, by simp [hin]âŸ©
    Â· simp only [hist, hin, â†“reduceDIte]
      refine Measurable.prodMk (by fun_prop) ?_
      change Measurable ((fun (x : (â„• â†’ Î± â†’ R) Ã— â„• Ã— Î±) â†¦ x.1 x.2.1 x.2.2) âˆ˜
        (fun x â†¦ (x.2, pullCount' n (hist alg x n) (algFunction alg n (hist alg x n) (x.1 (n + 1))),
          (algFunction alg n (hist alg x n) (x.1 (n + 1))))))
      have h1 : Measurable (fun (x : (â„• â†’ Î± â†’ R) Ã— â„• Ã— Î±) â†¦ x.1 x.2.1 x.2.2) :=
        measurable_from_prod_countable_left fun p : â„• Ã— Î± â†¦ (by simp only; fun_prop)
      refine Measurable.comp (by fun_prop) (Measurable.prodMk (by fun_prop) ?_)
      refine Measurable.prodMk ?_ (by fun_prop)
      exact measurable_pullCount'_action_add_one n hn

noncomputable
def action [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) (Ï‰ : probSpace Î± R) : Î± :=
  (hist alg Ï‰ n âŸ¨n, by simpâŸ©).1

lemma action_zero [DecidableEq Î±] (alg : Algorithm Î± R) :
    action alg 0 = fun Ï‰ â†¦ initAlgFunction alg (Ï‰.1 0) := by
  ext
  simp [action, hist_zero]

lemma action_add_one_eq [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    action alg (n + 1) = fun Ï‰ â†¦ algFunction alg n (hist alg Ï‰ n) (Ï‰.1 (n + 1)) := by
  ext Ï‰
  rw [action, hist_add_one]
  simp only [add_le_iff_nonpos_right, nonpos_iff_eq_zero, one_ne_zero, â†“reduceDIte]

@[fun_prop]
lemma measurable_action [DecidableEq Î±] [Countable Î±] (alg : Algorithm Î± R) (n : â„•) :
    Measurable (action alg n) := by unfold action; fun_prop

noncomputable
def reward [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) (Ï‰ : probSpace Î± R) : R :=
  (hist alg Ï‰ n âŸ¨n, by simpâŸ©).2

lemma reward_zero [DecidableEq Î±] (alg : Algorithm Î± R) :
    reward alg 0 = fun Ï‰ â†¦ Ï‰.2 0 (action alg 0 Ï‰) := by
  ext
  simp [reward, hist_zero, action_zero]

lemma reward_add_one [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    reward alg (n + 1) =
      fun Ï‰ â†¦ Ï‰.2 (pullCount' n (hist alg Ï‰ n) (action alg (n + 1) Ï‰)) (action alg (n + 1) Ï‰) := by
  ext Ï‰
  simp [reward, hist_add_one, action_add_one_eq]

lemma reward_eq [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    reward alg n = fun Ï‰ â†¦ Ï‰.2 (pullCount (action alg) (action alg n Ï‰) n Ï‰) (action alg n Ï‰) := by
  cases n with
  | zero => ext; simp [reward_zero, action_zero]
  | succ n =>
    ext Ï‰
    rw [reward, hist_add_one]
    simp only [add_le_iff_nonpos_right, nonpos_iff_eq_zero, one_ne_zero, â†“reduceDIte]
    rw [action_add_one_eq, pullCount_eq_pullCount' (R' := reward alg) (by simp)]
    simp only [Nat.add_one_sub_one]
    rw [hist_eq]
    rfl

@[fun_prop]
lemma measurable_reward [DecidableEq Î±] [Countable Î±] (alg : Algorithm Î± R) (n : â„•) :
    Measurable (reward alg n) := by unfold reward; fun_prop

lemma hist_add_one_eq_IicSuccProd [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R)
    (n : â„•) :
    hist alg Ï‰ (n + 1) =
      (MeasurableEquiv.IicSuccProd (fun _ â†¦ Î± Ã— R) n).symm
        (hist alg Ï‰ n, (action alg (n + 1) Ï‰, reward alg (n + 1) Ï‰)) := by
  rw [hist_add_one_eq_IicSuccProd', reward_add_one, action_add_one_eq]

variable [DecidableEq Î±] [Countable Î±]

lemma hasLaw_action_zero (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    HasLaw (action alg 0) alg.p0 (arrayMeasure Î½) where
  map_eq := by
    calc (arrayMeasure Î½).map (fun Ï‰ â†¦ initAlgFunction alg (Ï‰.1 0))
    _ = ((arrayMeasure Î½).fst.map (Function.eval 0)).map (initAlgFunction alg) := by
      rw [Measure.fst, Measure.map_map (by fun_prop) (by fun_prop),
        Measure.map_map (by fun_prop) (by fun_prop)]
      rfl
    _ = (volume : Measure I).map (initAlgFunction alg) := by
      simp only [arrayMeasure, Measure.fst_prod]
      rw [(measurePreserving_eval_infinitePi (fun _ â†¦ volume) 0).map_eq]
    _ = alg.p0 := initAlgFunction_map alg

variable [StandardBorelSpace R] [Nonempty R]

omit [Nonempty Î±] [StandardBorelSpace Î±] [DecidableEq Î±] [Countable Î±]
  [StandardBorelSpace R] [Nonempty R] in
lemma indepFun_fst_snd (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    IndepFun Prod.fst Prod.snd (arrayMeasure Î½) :=
  indepFun_prod measurable_id measurable_id

omit [Nonempty Î±] [StandardBorelSpace Î±] [DecidableEq Î±] [Countable Î±]
  [StandardBorelSpace R] [Nonempty R] in
lemma indepFun_fst_zero_snd_zero_action (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) :
    IndepFun (fun Ï‰ â†¦ Ï‰.1 0) (fun Ï‰ â†¦ Ï‰.2 0 a) (arrayMeasure Î½) :=
  indepFun_prod (X := fun Ï‰ : â„• â†’ I â†¦ Ï‰ 0) (Y := fun Ï‰ : â„• â†’ Î± â†’ R â†¦ Ï‰ 0 a)
    (by fun_prop) (by fun_prop)

omit [Nonempty Î±] [StandardBorelSpace Î±] [DecidableEq Î±] [Countable Î±]
  [StandardBorelSpace R] [Nonempty R] in
lemma map_snd_apply_arrayMeasure {Î½ : Kernel Î± R} [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    (arrayMeasure Î½).map (fun Ï‰ â†¦ Ï‰.2 n a) = Î½ a := by
  calc (arrayMeasure Î½).map (fun Ï‰ â†¦ Ï‰.2 n a)
  _ = (arrayMeasure Î½).snd.map (fun Ï‰ â†¦ Ï‰ n a) := by
    rw [Measure.snd, Measure.map_map (by fun_prop) (by fun_prop)]
    rfl
  _ = Î½ a := by
    rw [arrayMeasure, Measure.snd_prod, Bandit.streamMeasure]
    have : (fun Ï‰ â†¦ Ï‰ n a) = (fun h : Î± â†’ R â†¦ h a) âˆ˜ (fun Ï‰ : â„• â†’ Î± â†’ R â†¦ Ï‰ n) := rfl
    rw [this, â† Measure.map_map (by fun_prop) (by fun_prop), Measure.infinitePi_map_eval,
      Measure.infinitePi_map_eval]

lemma hasCondDistrib_reward_zero (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    HasCondDistrib (reward alg 0) (action alg 0) Î½ (arrayMeasure Î½) where
  condDistrib_eq := by
    refine (condDistrib_ae_eq_cond (by fun_prop) (by fun_prop)).trans ?_
    rw [Filter.EventuallyEq, ae_iff_of_countable]
    intro a ha
    simp only [reward_zero]
    calc ((arrayMeasure Î½)[|action alg 0 â»Â¹' {a}]).map (fun Ï‰ â†¦ Ï‰.2 0 (action alg 0 Ï‰))
    _ = ((arrayMeasure Î½)[|action alg 0 â»Â¹' {a}]).map (fun Ï‰ â†¦ Ï‰.2 0 a) := by
      refine Measure.map_congr
        (ae_cond_of_forall_mem ((measurableSet_singleton _).preimage (by fun_prop)) ?_)
      intro x hx
      simp only [Set.mem_preimage, Set.mem_singleton_iff] at hx
      simp [hx]
    _ = Î½ a := by
      rw [cond_of_indepFun]
      Â· exact map_snd_apply_arrayMeasure 0 a
      Â· have : (fun Ï‰ â†¦ Ï‰.1 0) âŸ‚áµ¢[arrayMeasure Î½] fun Ï‰ â†¦ Ï‰.2 0 a :=
          indepFun_fst_zero_snd_zero_action Î½ a
        rw [action_zero]
        exact this.comp (Ï† := initAlgFunction alg) (by fun_prop) measurable_id
      Â· fun_prop
      Â· fun_prop
      Â· simp
      Â· rwa [Measure.map_apply (by fun_prop) (by simp)] at ha

lemma indepFun_fst_add_one_aux (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (fun Ï‰ â†¦ Ï‰.1 (n + 1)) âŸ‚áµ¢[arrayMeasure Î½] (fun Ï‰ â†¦ (fun (i : Iic n) â†¦ Ï‰.1 i, Ï‰.2)) := by
  rw [indepFun_iff_map_prod_eq_prod_map_map (by fun_prop) (by fun_prop)]
  sorry

omit [StandardBorelSpace R] [Nonempty R] in
lemma measurable_hist_todo (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    Measurable[MeasurableSpace.comap (fun Ï‰ â†¦ (fun (i : Iic n) â†¦ Ï‰.1 i, Ï‰.2)) inferInstance]
      (hist alg Â· n) := by
  induction n with
  | zero =>
    simp only [hist_zero]
    have : (fun (Ï‰ : probSpace Î± R) (i : Iic 0) â†¦
          (initAlgFunction alg (Ï‰.1 0), Ï‰.2 0 (initAlgFunction alg (Ï‰.1 0)))) =
        (fun (p : (Iic 0 â†’ I) Ã— (â„• â†’ Î± â†’ R)) (i : Iic 0) â†¦ (initAlgFunction alg (p.1 âŸ¨0, by simpâŸ©),
          p.2 0 (initAlgFunction alg (p.1 âŸ¨0, by simpâŸ©)))) âˆ˜
        (fun (Ï‰  : probSpace Î± R) â†¦ (fun (i : Iic 0) â†¦ Ï‰.1 i, Ï‰.2)) := rfl
    rw [this]
    have h_meas : Measurable (fun (p : (Iic 0 â†’ I) Ã— (â„• â†’ Î± â†’ R)) (i : Iic 0) â†¦
        (initAlgFunction alg (p.1 âŸ¨0, by simpâŸ©),
          p.2 0 (initAlgFunction alg (p.1 âŸ¨0, by simpâŸ©)))) := by
      rw [measurable_pi_iff]
      intro i
      refine Measurable.prodMk (by fun_prop) ?_
      change Measurable ((fun x : (Î± Ã— (â„• â†’ Î± â†’ R)) â†¦ x.2 0 x.1) âˆ˜
        (fun x : (Iic 0 â†’ I) Ã— (â„• â†’ Î± â†’ R) â†¦ (initAlgFunction alg (x.1 âŸ¨0, by simpâŸ©), x.2)))
      have : Measurable (fun x : (Î± Ã— (â„• â†’ Î± â†’ R)) â†¦ x.2 0 x.1) :=
        measurable_from_prod_countable_right fun p â†¦ by simp only; fun_prop
      exact this.comp (by fun_prop)
    refine Measurable.comp h_meas ?_
    exact Measurable.of_comap_le le_rfl
  | succ n hn =>
    simp_rw [hist_add_one_eq_IicSuccProd]
    have h_hist : Measurable[MeasurableSpace.comap (fun Ï‰ â†¦ (fun (i : Iic (n + 1)) â†¦ Ï‰.1 i, Ï‰.2))
        inferInstance] (hist alg Â· n) := by
      rw [measurable_iff_comap_le] at hn âŠ¢
      refine hn.trans ?_
      rw [â† measurable_iff_comap_le]
      have : (fun (Ï‰ : probSpace Î± R) â†¦ (fun (i : Iic n) â†¦ Ï‰.1 i, Ï‰.2)) =
          (fun (p : (Iic (n + 1) â†’ I) Ã— (â„• â†’ Î± â†’ R)) â†¦ (fun (i : Iic n) â†¦ p.1 âŸ¨i, by grindâŸ©, p.2)) âˆ˜
          (fun (Ï‰ : probSpace Î± R) â†¦ (fun (i : Iic (n + 1)) â†¦ Ï‰.1 i, Ï‰.2)) := rfl
      rw [this]
      exact Measurable.comp (by fun_prop) (Measurable.of_comap_le le_rfl)
    refine (MeasurableEquiv.measurable _).comp (Measurable.prodMk h_hist ?_)
    have h_action : Measurable[MeasurableSpace.comap (fun Ï‰ â†¦ (fun (i : Iic (n + 1)) â†¦ Ï‰.1 i, Ï‰.2))
        inferInstance] (action alg (n + 1)) := by
      rw [action_add_one_eq]
      have : (fun Ï‰ â†¦ algFunction alg n (hist alg Ï‰ n) (Ï‰.1 (n + 1))) =
          (Function.uncurry (algFunction alg n)) âˆ˜ (fun Ï‰ â†¦ (hist alg Ï‰ n, Ï‰.1 (n + 1))) := rfl
      rw [this]
      refine (measurable_algFunction alg n).comp (h_hist.prodMk ?_)
      have : (fun Ï‰ : probSpace Î± R â†¦ Ï‰.1 (n + 1)) =
          (fun (p : (Iic (n + 1) â†’ I) Ã— (â„• â†’ Î± â†’ R)) â†¦ p.1 âŸ¨n + 1, by simpâŸ©) âˆ˜
          (fun Ï‰ â†¦ (fun (i : Iic (n + 1)) â†¦ Ï‰.1 i, Ï‰.2)) := rfl
      rw [this]
      exact Measurable.comp (by fun_prop) (Measurable.of_comap_le le_rfl)
    refine h_action.prodMk ?_
    rw [reward_add_one]
    have : (fun Ï‰ â†¦ Ï‰.2 (pullCount' n (hist alg Ï‰ n) (action alg (n + 1) Ï‰))
          (action alg (n + 1) Ï‰)) =
        (fun p : ((Iic (n + 1) â†’ I) Ã— (â„• â†’ Î± â†’ R)) Ã—
            (Iic n â†’ Î± Ã— R) Ã— Î± â†¦ p.1.2 (pullCount' n p.2.1 p.2.2) p.2.2) âˆ˜
          (fun Ï‰ â†¦ ((fun i : Iic (n + 1) â†¦ Ï‰.1 i, Ï‰.2), hist alg Ï‰ n, action alg (n + 1) Ï‰)) := rfl
    rw [this]
    have h_meas : Measurable
        (fun p : ((Iic (n + 1) â†’ I) Ã— (â„• â†’ Î± â†’ R)) Ã— (Iic n â†’ Î± Ã— R) Ã— Î± â†¦
          p.1.2 (pullCount' n p.2.1 p.2.2) p.2.2) := by
      have : (fun p : ((Iic (n + 1) â†’ I) Ã— (â„• â†’ Î± â†’ R)) Ã— (Iic n â†’ Î± Ã— R) Ã— Î± â†¦
            p.1.2 (pullCount' n p.2.1 p.2.2) p.2.2) =
          (fun (x : (â„• â†’ Î± â†’ R) Ã— â„• Ã— Î±) â†¦ x.1 x.2.1 x.2.2) âˆ˜
          (fun p : ((Iic (n + 1) â†’ I) Ã— (â„• â†’ Î± â†’ R)) Ã— (Iic n â†’ Î± Ã— R) Ã— Î± â†¦
            (p.1.2, pullCount' n p.2.1 p.2.2, p.2.2)) := rfl
      rw [this]
      refine Measurable.comp (measurable_from_prod_countable_left (m := inferInstance) fun p â†¦ ?_)
        ?_
      Â· simp only; fun_prop
      refine Measurable.prodMk (by fun_prop) (Measurable.prodMk ?_ (by fun_prop))
      exact (measurable_uncurry_pullCount' (Î± := Î±) (mR := mR) n).comp (by fun_prop)
    refine h_meas.comp (Measurable.prodMk ?_ (Measurable.prodMk h_hist h_action))
    exact Measurable.of_comap_le le_rfl

lemma indepFun_fst_add_one_hist (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    IndepFun (fun Ï‰ â†¦ Ï‰.1 (n + 1)) (hist alg Â· n) (arrayMeasure Î½) :=
  (indepFun_fst_add_one_aux alg Î½ n).of_measurable_right (measurable_hist_todo alg Î½ n)

lemma hasCondDistrib_action' (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasCondDistrib (action alg (n + 1)) (hist alg Â· n) (alg.policy n) (arrayMeasure Î½) := by
  rw [action_add_one_eq]
  have h_fun Ï‰ := algFunction_map alg n (hist alg Ï‰ n)
  refine âŸ¨by fun_prop, by fun_prop, ?_âŸ©
  refine condDistrib_ae_eq_of_measure_eq_compProd _ (by fun_prop) ?_
  have h_indep : (arrayMeasure Î½).map (fun Ï‰ â†¦ (Ï‰.1 (n + 1), hist alg Ï‰ n)) =
      (â„™).prod ((arrayMeasure Î½).map (hist alg Â· n)) := by
    have h_indep' := indepFun_fst_add_one_hist alg Î½ n
    rw [indepFun_iff_map_prod_eq_prod_map_map (by fun_prop) (by fun_prop)] at h_indep'
    rw [h_indep']
    congr
    simp only [arrayMeasure]
    calc ((Measure.infinitePi fun x â†¦ â„™).prod (Bandit.streamMeasure Î½)).map (fun Ï‰ â†¦ Ï‰.1 (n + 1))
    _ = (Measure.infinitePi fun x â†¦ â„™).map (Function.eval (n + 1)) := by
      nth_rw 2 [â† Measure.fst_prod (Î¼ := Measure.infinitePi fun x â†¦ â„™)
        (Î½ := Bandit.streamMeasure Î½)]
      rw [Measure.fst, Measure.map_map (by fun_prop) (by fun_prop)]
      rfl
    _ = â„™ := by rw [Measure.infinitePi_map_eval]
  have : (fun x â†¦ (hist alg x n, algFunction alg n (hist alg x n) (x.1 (n + 1)))) =
      (fun p â†¦ (p.2, algFunction alg n (p.2) (p.1))) âˆ˜ (fun x â†¦ (x.1 (n + 1), hist alg x n)) := rfl
  rw [this, â† Measure.map_map (by fun_prop) (by fun_prop), h_indep]
  have : (â„™ : Measure I).prod ((arrayMeasure Î½).map (hist alg Â· n)) =
      ((Kernel.const _ â„™) Ã—â‚– Kernel.id) âˆ˜â‚˜ ((arrayMeasure Î½).map (hist alg Â· n)) := by
    have h := Measure.compProd_const (Î¼ := (arrayMeasure Î½).map (hist alg Â· n))
      (Î½ := (â„™ : Measure I))
    rw [Measure.compProd_eq_comp_prod] at h
    rw [â† Measure.prod_swap, â† h, â† Measure.deterministic_comp_eq_map (by fun_prop),
      Measure.comp_assoc, â† Kernel.swap, Kernel.swap_prod]
  rw [this, â† Measure.deterministic_comp_eq_map (by fun_prop),
    â† Measure.deterministic_comp_eq_map (by fun_prop), Measure.compProd_eq_comp_prod,
    Measure.comp_assoc, Measure.comp_assoc, Measure.comp_assoc]
  congr 2
  ext Ï‰ : 1
  simp only [Kernel.deterministic_comp_eq_map, Kernel.comp_deterministic_eq_comap, Kernel.coe_comap,
    Function.comp_apply]
  rw [Kernel.map_apply _ (by fun_prop), Kernel.prod_apply, Kernel.const_apply, Kernel.id_apply,
    Kernel.prod_apply, Kernel.id_apply, â† h_fun]
  calc (((â„™).prod (Measure.dirac (hist alg Ï‰ n)))).map (fun p â†¦ (p.2, algFunction alg n p.2 p.1))
  _ = (((â„™).prod (Measure.dirac (hist alg Ï‰ n))).map Prod.swap).map
      (fun p â†¦ (p.1, algFunction alg n p.1 p.2)) := by
    rw [Measure.map_map (by fun_prop) (by fun_prop)]
    rfl
  _ = ((Measure.dirac (hist alg Ï‰ n)).prod â„™).map (fun p â†¦ (p.1, algFunction alg n p.1 p.2)) := by
    rw [Measure.prod_swap]
  _ = (Measure.dirac (hist alg Ï‰ n)).prod ((â„™).map (algFunction alg n (hist alg Ï‰ n))) := by
    ext s hs
    rw [Measure.map_apply (by fun_prop) hs, Measure.prod_apply, lintegral_dirac, Measure.prod_apply,
      lintegral_dirac, Measure.map_apply (by fun_prop)]
    Â· congr
    Â· exact hs.preimage (by fun_prop)
    Â· exact hs
    Â· exact hs.preimage (by fun_prop)

omit [Countable Î±] [StandardBorelSpace R] [Nonempty R] in
lemma hist_congr (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•)
    {Ï‰ Ï‰' : probSpace Î± R}
    (hÏ‰1 : âˆ€ i â‰¤ n, Ï‰.1 i = Ï‰'.1 i)
    (hÏ‰2 : âˆ€ i a, i < pullCount (action alg) a (n + 1) Ï‰ â†’ Ï‰.2 i a = Ï‰'.2 i a) :
    hist alg Ï‰ n = hist alg Ï‰' n := by
  induction n with
  | zero =>
    simp only [zero_add, pullCount_one] at hÏ‰2
    simp_rw [hist_zero]
    ext i : 1
    simp only [le_refl, hÏ‰1, Prod.mk.injEq, true_and]
    refine hÏ‰2 0 _ ?_
    simp [action, hÏ‰1]
  | succ n hn =>
    simp_rw [hist_add_one_eq_IicSuccProd]
    specialize hn fun i hin â†¦ hÏ‰1 i (by grind)
    have h_hist : hist alg Ï‰ n = hist alg Ï‰' n := by
      refine hn fun i a hi â†¦ hÏ‰2 i a (hi.trans_le ?_)
      exact pullCount_mono _ (by lia) _
    have h_action : action alg (n + 1) Ï‰ = action alg (n + 1) Ï‰' := by
      simp_rw [action_add_one_eq]
      rw [h_hist, hÏ‰1 _ le_rfl]
    congr 3
    simp only [reward_add_one, h_hist, h_action]
    refine hÏ‰2 _ _ ?_
    rw [pullCount_add_one, h_action]
    simp only [â†“reduceIte]
    rw [pullCount_eq_pullCount' (R' := reward alg) (by simp)]
    simp only [Nat.add_one_sub_one]
    rw [â† h_hist, hist_eq]
    change pullCount' n  (fun i â†¦ (action alg i Ï‰, reward alg i Ï‰)) (action alg (n + 1) Ï‰') <
      pullCount' n (fun i â†¦ (action alg i Ï‰, reward alg i Ï‰)) (action alg (n + 1) Ï‰') + 1
    grind

-- very bad name
noncomputable
def truePast (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (a : Î±) (n : â„•) (Ï‰ : probSpace Î± R) :
    probSpace Î± R :=
  (Ï‰.1, fun i b â†¦ if b = a then Ï‰.2 (min i ((pullCount (action alg) a (n + 1) Ï‰) - 1)) a
    else Ï‰.2 i b)

omit [Countable Î±] [StandardBorelSpace R] [Nonempty R] in
lemma truePast_eq_of_pullCount_eq (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (a : Î±) (n m : â„•) (Ï‰ : probSpace Î± R)
    (h_pc : pullCount (action alg) a (n + 1) Ï‰ = m) :
    truePast alg Î½ a n Ï‰ = (Ï‰.1, fun i b â†¦ if b = a then Ï‰.2 (min i (m - 1)) a else Ï‰.2 i b) := by
  simp [truePast, h_pc]

omit [StandardBorelSpace R] [Nonempty R] in
lemma measurable_hist_truePast (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (a : Î±) (n : â„•) :
    Measurable[MeasurableSpace.comap (truePast alg Î½ a n) inferInstance] (hist alg Â· n) := by
  have h_eq : (hist alg Â· n) = (hist alg Â· n) âˆ˜ (truePast alg Î½ a n) := by
    ext Ï‰ : 1
    refine hist_congr alg Î½ n (fun _ _ â†¦ rfl) fun i b hi â†¦ ?_
    by_cases hb : b = a
    Â· subst hb
      simp only [truePast, â†“reduceIte]
      rw [min_eq_left]
      grind
    Â· simp [truePast, hb]
  rw [h_eq]
  refine Measurable.comp ?_ (Measurable.of_comap_le le_rfl)
  fun_prop

omit [StandardBorelSpace R] [Nonempty R] in
lemma measurable_action_add_one_truePast (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (n : â„•) :
    Measurable[MeasurableSpace.comap (truePast alg Î½ a n) inferInstance]
      (action alg (n + 1)) := by
  rw [action_add_one_eq]
  change Measurable[MeasurableSpace.comap (truePast alg Î½ a n) inferInstance]
    ((fun p â†¦ algFunction alg n p.1 p.2) âˆ˜ (fun Ï‰ â†¦ (hist alg Ï‰ n, Ï‰.1 (n + 1))))
  refine (measurable_algFunction alg n).comp (Measurable.prodMk ?_ ?_)
  Â· exact measurable_hist_truePast alg Î½ a n
  Â· have : (fun Ï‰ â†¦ Ï‰.1 (n + 1)) =
      (fun (p : probSpace Î± R) â†¦ p.1 (n + 1)) âˆ˜ (truePast alg Î½ a n) := rfl
    rw [this]
    exact Measurable.comp (by fun_prop) (Measurable.of_comap_le le_rfl)

omit [StandardBorelSpace R] [Nonempty R] in
lemma measurable_pullCount_add_one_truePast (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (n : â„•) :
    Measurable[MeasurableSpace.comap (truePast alg Î½ a n) inferInstance]
      (pullCount (action alg) a (n + 1)) := by
  change Measurable[MeasurableSpace.comap (truePast alg Î½ a n) inferInstance]
    (fun Ï‰ â†¦ pullCount (action alg) a (n + 1) Ï‰)
  simp_rw [pullCount_eq_sum]
  refine measurable_sum _ fun i hi â†¦ Measurable.ite ?_ (by fun_prop) (by fun_prop)
  refine (measurableSet_singleton _).preimage ?_
  have h_meas := measurable_hist_truePast alg Î½ a n
  simp_rw [hist_eq _ _ n, @measurable_pi_iff] at h_meas
  exact (h_meas âŸ¨i, by grindâŸ©).fst

lemma indepFun_snd_apply_aux (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (m n : â„•) :
    (fun Ï‰ â†¦ Ï‰.2 m a) âŸ‚áµ¢[arrayMeasure Î½]
      (fun Ï‰ â†¦ (Ï‰.1, fun k b â†¦ if b = a then Ï‰.2 (min k (m - 1)) b else Ï‰.2 k b)) := by
  sorry

omit [Countable Î±] [StandardBorelSpace R] [Nonempty R] in
lemma stepsUntil_congr_aux (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (m n : â„•) {Ï‰ Ï‰' : probSpace Î± R}
    (hÏ‰1 : âˆ€ i, Ï‰.1 i = Ï‰'.1 i) (hÏ‰2_ne : âˆ€ i b, b â‰  a â†’ Ï‰.2 i b = Ï‰'.2 i b)
    (hÏ‰2_eq : âˆ€ i â‰¤ m - 1, Ï‰.2 i a = Ï‰'.2 i a)
    (h_eq : action alg (n + 1) Ï‰ = a âˆ§ pullCount (action alg) a (n + 1) Ï‰ = m) :
    action alg (n + 1) Ï‰' = a âˆ§ pullCount (action alg) a (n + 1) Ï‰' = m := by
  obtain âŸ¨h_action, h_pcâŸ© := h_eq
  have h_hist := hist_congr alg Î½ n (Ï‰ := Ï‰) (Ï‰' := Ï‰') (by grind) fun i b hi â†¦ ?_
  swap
  Â· rcases eq_or_ne b a with (rfl | hba)
    Â· refine hÏ‰2_eq i ?_
      rw [h_pc] at hi
      grind
    Â· grind
  constructor
  Â· rw [â† h_action, action_add_one_eq]
    simp [h_hist, hÏ‰1]
  Â· simp_rw [â† h_pc, pullCount_eq_sum]
    refine Finset.sum_congr rfl fun i hi â†¦ ?_
    congr 2
    rw [hist_eq _ _ n, hist_eq _ _ n, funext_iff] at h_hist
    unfold action
    specialize h_hist âŸ¨i, by grindâŸ©
    simp only at h_hist
    rw [h_hist]

omit [Countable Î±] [StandardBorelSpace R] [Nonempty R] in
lemma stepsUntil_congr (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (m n : â„•) {Ï‰ Ï‰' : probSpace Î± R}
    (hÏ‰1 : âˆ€ i, Ï‰.1 i = Ï‰'.1 i) (hÏ‰2_ne : âˆ€ i b, b â‰  a â†’ Ï‰.2 i b = Ï‰'.2 i b)
    (hÏ‰2_eq : âˆ€ i â‰¤ m - 1, Ï‰.2 i a = Ï‰'.2 i a) :
    (action alg (n + 1) Ï‰ = a âˆ§ pullCount (action alg) a (n + 1) Ï‰ = m) â†”
      (action alg (n + 1) Ï‰' = a âˆ§ pullCount (action alg) a (n + 1) Ï‰' = m) :=
  âŸ¨stepsUntil_congr_aux alg Î½ a m n hÏ‰1 hÏ‰2_ne hÏ‰2_eq,
    stepsUntil_congr_aux alg Î½ a m n (by grind) (by grind) (by grind)âŸ©

omit [Countable Î±] [StandardBorelSpace R] [Nonempty R] in
lemma stepsUntil_indicator_congr (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (m n : â„•) {Ï‰ Ï‰' : probSpace Î± R}
    (hÏ‰1 : âˆ€ i, Ï‰.1 i = Ï‰'.1 i) (hÏ‰2_ne : âˆ€ i b, b â‰  a â†’ Ï‰.2 i b = Ï‰'.2 i b)
    (hÏ‰2_eq : âˆ€ i â‰¤ m - 1, Ï‰.2 i a = Ï‰'.2 i a) :
    {Ï‰ | action alg (n + 1) Ï‰ = a âˆ§ pullCount (action alg) a (n + 1) Ï‰ = m}.indicator (fun _ â†¦ 1)
        Ï‰ =
      {Ï‰ | action alg (n + 1) Ï‰ = a âˆ§ pullCount (action alg) a (n + 1) Ï‰ = m}.indicator
        (fun _ â†¦ 1) Ï‰' := by
  simp only [Set.indicator_apply, Set.mem_setOf_eq]
  simp_rw [stepsUntil_congr alg Î½ a m n hÏ‰1 hÏ‰2_ne hÏ‰2_eq]

omit [StandardBorelSpace R] [Nonempty R] in
lemma measurable_stepsUntil (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (m n : â„•) :
    Measurable[MeasurableSpace.comap
        (fun Ï‰ â†¦ (Ï‰.1, fun k b â†¦ if b = a then Ï‰.2 (min k (m - 1)) b else Ï‰.2 k b)) inferInstance]
      (({Ï‰ | action alg (n + 1) Ï‰ = a âˆ§
        pullCount (action alg) a (n + 1) Ï‰ = m}).indicator (fun _ â†¦ 1)) := by
  let f := ({Ï‰ | action alg (n + 1) Ï‰ = a âˆ§ pullCount (action alg) a (n + 1) Ï‰ = m}).indicator
    (fun _ â†¦ 1)
  have h_eq : f = f âˆ˜
      fun Ï‰ â†¦ (Ï‰.1, fun k b â†¦ if b = a then Ï‰.2 (min k (m - 1)) b else Ï‰.2 k b) := by
    ext Ï‰
    exact stepsUntil_indicator_congr alg Î½ a m n (by grind) (by grind) (by grind)
  change Measurable[MeasurableSpace.comap
    (fun Ï‰ â†¦ (Ï‰.1, fun k b â†¦ if b = a then Ï‰.2 (min k (m - 1)) b else Ï‰.2 k b)) inferInstance] f
  rw [h_eq]
  refine Measurable.comp ?_ (Measurable.of_comap_le le_rfl)
  refine Measurable.indicator (by fun_prop) ?_
  exact MeasurableSet.inter ((measurableSet_singleton _).preimage (by fun_prop))
    ((measurableSet_singleton _).preimage (by fun_prop))

lemma indepFun_snd_apply_pullCount_action (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (m n : â„•) :
    (fun Ï‰ â†¦ Ï‰.2 m a) âŸ‚áµ¢[arrayMeasure Î½]
      ({Ï‰ | action alg (n + 1) Ï‰ = a âˆ§
        pullCount (action alg) a (n + 1) Ï‰ = m}).indicator (fun _ â†¦ 1) :=
  (indepFun_snd_apply_aux alg Î½ a m n).of_measurable_right (measurable_stepsUntil alg Î½ a m n)

omit [StandardBorelSpace R] [Nonempty R] in
@[fun_prop]
lemma measurable_pullCount_action_add_one (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    Measurable (fun Ï‰ â†¦ pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰) := by
  change Measurable ((fun p : (probSpace Î± R) Ã— Î± â†¦ pullCount (action alg) p.2 (n + 1) p.1) âˆ˜
    (fun Ï‰ : probSpace Î± R â†¦ (Ï‰, action alg (n + 1) Ï‰)))
  exact (measurable_uncurry_pullCount (by fun_prop) _).comp (by fun_prop)

lemma hasCondDistrib_reward_pullCount_action
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasCondDistrib (reward alg (n + 1))
      (fun Ï‰ â†¦ (action alg (n + 1) Ï‰, pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰))
      (Î½.prodMkRight _) (arrayMeasure Î½) := by
  have h_meas : Measurable fun Ï‰ â†¦ pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰ := by
    change Measurable ((fun p : (probSpace Î± R) Ã— Î± â†¦ pullCount (action alg) p.2 (n + 1) p.1) âˆ˜
      (fun Ï‰ : probSpace Î± R â†¦ (Ï‰, action alg (n + 1) Ï‰)))
    exact (measurable_uncurry_pullCount (by fun_prop) _).comp (by fun_prop)
  refine âŸ¨by fun_prop, by fun_prop, ?_âŸ©
  refine (condDistrib_ae_eq_cond
    (Measurable.prodMk (by fun_prop) (by fun_prop)) (by fun_prop)).trans ?_
  rw [Filter.EventuallyEq, ae_iff_of_countable]
  intro âŸ¨a, mâŸ© ham
  simp only [Kernel.prodMkRight_apply]
  calc
    Measure.map (reward alg (n + 1))
      (arrayMeasure Î½)[|(fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
        pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰)) â»Â¹' {(a, m)}]
  _ = Measure.map (fun Ï‰ â†¦ Ï‰.2 m a)
      (arrayMeasure Î½)[|(fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
        pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰)) â»Â¹' {(a, m)}] := by
    rw [reward_eq]
    refine Measure.map_congr
      (ae_cond_of_forall_mem ((measurableSet_singleton _).preimage (by fun_prop)) (fun x hx â†¦ ?_))
    simp only [Set.mem_preimage, Set.mem_singleton_iff, Prod.mk.injEq] at hx
    simp only [hx.1] at hx âŠ¢
    simp [hx.2]
  _ = Measure.map (fun Ï‰ â†¦ Ï‰.2 m a)
      (arrayMeasure Î½)[|({Ï‰ | action alg (n + 1) Ï‰ = a âˆ§
        pullCount (action alg) a (n + 1) Ï‰ = m}).indicator 1 â»Â¹' {1}] := by
    congr with Ï‰
    simp only [Set.mem_preimage, Set.mem_singleton_iff, Prod.mk.injEq, Set.indicator_apply,
      Set.mem_setOf_eq, Pi.one_apply, ite_eq_left_iff, not_and, zero_ne_one, imp_false,
      Classical.not_imp, Decidable.not_not, and_congr_right_iff]
    intro ha
    simp [ha]
  _ = Î½ a := by
    rw [cond_of_indepFun, map_snd_apply_arrayMeasure m a]
    Â· exact (indepFun_snd_apply_pullCount_action alg Î½ a m n).symm
    Â· refine Measurable.indicator (by fun_prop) ?_
      exact MeasurableSet.inter ((measurableSet_singleton _).preimage (by fun_prop))
        ((measurableSet_singleton _).preimage (by fun_prop))
    Â· fun_prop
    Â· simp
    Â· rw [Measure.map_apply (by fun_prop) (by simp)] at ham
      convert ham
      ext Ï‰
      simp only [Set.mem_preimage, Set.indicator_apply, Set.mem_setOf_eq, Pi.one_apply,
        Set.mem_singleton_iff, ite_eq_left_iff, not_and, zero_ne_one, imp_false, Classical.not_imp,
        Decidable.not_not, Prod.mk.injEq, and_congr_right_iff]
      intro ha
      simp [ha]

-- lemma hasCondDistrib_reward_hist_action_pullCount'
--     (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (n m : â„•) :
--     HasCondDistrib (reward alg (n + 1))
--       (fun Ï‰ â†¦ (hist alg Ï‰ n, {Ï‰' | action alg (n + 1) Ï‰' = a âˆ§
--         pullCount (action alg) (action alg (n + 1) Ï‰') (n + 1) Ï‰' = m}.indicator
--           (fun _ â†¦ (1 : â„•)) Ï‰))
--       (Kernel.const _ (Î½ a)) (arrayMeasure Î½) := by
--   sorry

omit [StandardBorelSpace R] [Nonempty R] in
lemma reward_ae_eq_cond
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (n m : â„•) :
    reward alg (n + 1) =áµ[(arrayMeasure Î½)[|(fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
        pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰)) â»Â¹' {(a, m)}]]
      (fun Ï‰ â†¦ Ï‰.2 m a) := by
  rw [reward_eq]
  refine ae_cond_of_forall_mem ?_ ?_
  Â· have : Measurable fun Ï‰ â†¦ pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰ := by
      change Measurable ((fun p : (probSpace Î± R) Ã— Î± â†¦ pullCount (action alg) p.2 (n + 1) p.1) âˆ˜
        (fun Ï‰ : probSpace Î± R â†¦ (Ï‰, action alg (n + 1) Ï‰)))
      exact (measurable_uncurry_pullCount (by fun_prop) _).comp (by fun_prop)
    exact (measurableSet_singleton _).preimage (by fun_prop)
  intro Ï‰ hÏ‰
  simp only [Set.mem_preimage, Set.mem_singleton_iff, Prod.mk.injEq] at hÏ‰
  simp only [hÏ‰.2]
  simp [hÏ‰.1]

lemma indepFun_cond_of_indepFun {Î± Î² Î³ : Type*} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²}
    {mÎ³ : MeasurableSpace Î³} {Î¼ : Measure Î±}
    {X : Î± â†’ Î²} {Y : Î± â†’ Î³} (hXY : X âŸ‚áµ¢[Î¼] Y) (hY : Measurable Y) {s : Set Î³}
    (hs : MeasurableSet s) :
    X âŸ‚áµ¢[Î¼[|Y â»Â¹' s]] Y := by
  by_cases h_zero : Î¼[|Y â»Â¹' s] = 0
  Â· simp only [h_zero]
    -- missing simp lemma : `X âŸ‚áµ¢[0] Y`
    simp [indepFun_iff_measure_inter_preimage_eq_mul]
  rw [cond_eq_zero] at h_zero
  push_neg at h_zero
  rw [indepFun_iff_measure_inter_preimage_eq_mul] at hXY âŠ¢
  intro u t hu ht
  rw [cond_apply (hs.preimage hY), cond_apply (hs.preimage hY), cond_apply (hs.preimage hY)]
  have h_eq : Y â»Â¹' s âˆ© (X â»Â¹' u âˆ© Y â»Â¹' t) = X â»Â¹' u âˆ© Y â»Â¹' (s âˆ© t) := by grind
  have hsu := hXY u s hu hs
  have hust := hXY u (s âˆ© t) hu (hs.inter ht)
  rw [Set.inter_comm] at hsu
  rw [hsu, h_eq, hust]
  simp_rw [mul_assoc]
  congr 1
  rw [â† mul_assoc (Î¼ (Y â»Â¹' s)), ENNReal.mul_inv_cancel h_zero.2 h_zero.1, one_mul]
  congr

lemma indepFun_todo {Î± Î² Î³ Î´ : Type*} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²}
    {mÎ³ : MeasurableSpace Î³} {mÎ´ : MeasurableSpace Î´} [MeasurableSingletonClass Î´] {Î¼ : Measure Î±}
    {X : Î± â†’ Î²} {Y : Î± â†’ Î³} (hXY : X âŸ‚áµ¢[Î¼] Y) (hY : Measurable Y)
    {Z : Î³ â†’ Î´} (hZ : Measurable Z) (z : Î´) :
    X âŸ‚áµ¢[Î¼[|(Z âˆ˜ Y) â»Â¹' {z}]] Y := by
  have h_preim : (Z âˆ˜ Y) â»Â¹' {z} = Y â»Â¹' (Z â»Â¹' {z}) := by grind
  simp_rw [h_preim]
  exact indepFun_cond_of_indepFun hXY hY (hZ (measurableSet_singleton z))

lemma indepFun_snd_hist_cond (alg : Algorithm Î± R)
    (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) (n m : â„•) :
    (fun Ï‰ â†¦ Ï‰.2 m a) âŸ‚áµ¢[(arrayMeasure Î½)[|(fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
      pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰)) â»Â¹' {(a, m)}]]
    (hist alg Â· n) := by
  have h_meas := measurable_hist_truePast alg Î½ a n
  refine IndepFun.of_measurable_right ?_ h_meas
  have h_ae_eq : truePast alg Î½ a n =áµ[(arrayMeasure Î½)[|(fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
        pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰)) â»Â¹' {(a, m)}]]
      (fun Ï‰ â†¦ (Ï‰.1, fun k b â†¦ if b = a then Ï‰.2 (min k (m - 1)) b else Ï‰.2 k b)) := by
    refine ae_cond_of_forall_mem ?_ fun x hx â†¦ ?_
    Â· refine (measurableSet_singleton _).preimage ?_
      have h_meas_pc : Measurable fun Ï‰ â†¦
          pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰ := by
        change Measurable ((fun p : (probSpace Î± R) Ã— Î± â†¦ pullCount (action alg) p.2 (n + 1) p.1) âˆ˜
          (fun Ï‰ : probSpace Î± R â†¦ (Ï‰, action alg (n + 1) Ï‰)))
        exact (measurable_uncurry_pullCount (by fun_prop) _).comp (by fun_prop)
      fun_prop
    simp only [Set.mem_preimage, Set.mem_singleton_iff, Prod.mk.injEq] at hx
    simp only [truePast]
    congr with i b
    by_cases hb : b = a
    Â· simp only [hb, â†“reduceIte]
      simp only [hx.1, true_and] at hx
      congr!
    Â· simp [hb]
  refine IndepFun.congr ?_ EventuallyEq.rfl h_ae_eq.symm
  suffices (fun Ï‰ â†¦ Ï‰.2 m a) âŸ‚áµ¢[(arrayMeasure Î½)[|(({Ï‰ | action alg (n + 1) Ï‰ = a âˆ§
        pullCount (action alg) a (n + 1) Ï‰ = m}).indicator (fun _ â†¦ 1)) â»Â¹' {1}]]
      fun Ï‰ â†¦ (Ï‰.1, fun k b â†¦ if b = a then Ï‰.2 (min k (m - 1)) b else Ï‰.2 k b) by
    convert this
    ext Ï‰
    simp only [Set.mem_preimage, Set.mem_singleton_iff, Prod.mk.injEq, Set.indicator_apply,
      Set.mem_setOf_eq, ite_eq_left_iff, not_and, zero_ne_one, imp_false,
      Classical.not_imp, Decidable.not_not, and_congr_right_iff]
    intro ha
    simp [ha]
  have h_meas := measurable_stepsUntil alg Î½ a m n
  obtain âŸ¨f, hf, hf_eqâŸ© := h_meas.exists_eq_measurable_comp
  simp_rw [hf_eq]
  refine indepFun_todo (Z := f) (z := 1) ?_ ?_ hf
  Â· exact indepFun_snd_apply_aux alg Î½ a m n
  Â· refine Measurable.prodMk (by fun_prop) ?_
    simp_rw [measurable_pi_iff]
    intro m a
    refine Measurable.ite ?_ (by fun_prop) (by fun_prop)
    exact MeasurableSet.const _

lemma hasCondDistrib_reward_hist_action_pullCount
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasCondDistrib (reward alg (n + 1))
      (fun Ï‰ â†¦ (hist alg Ï‰ n, action alg (n + 1) Ï‰,
        pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰))
      ((Î½.prodMkRight _).prodMkLeft _) (arrayMeasure Î½) := by
  have h_meas : Measurable fun Ï‰ â†¦ pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰ := by
    change Measurable ((fun p : (probSpace Î± R) Ã— Î± â†¦ pullCount (action alg) p.2 (n + 1) p.1) âˆ˜
      (fun Ï‰ : probSpace Î± R â†¦ (Ï‰, action alg (n + 1) Ï‰)))
    exact (measurable_uncurry_pullCount (by fun_prop) _).comp (by fun_prop)
  refine âŸ¨by fun_prop, by fun_prop, ?_âŸ©
  refine condDistrib_prod_of_forall_condDistrib_cond (by fun_prop) (by fun_prop) (by fun_prop) _ ?_
  intro (a, m) ham
  have h_eq : ((Î½.prodMkRight _).prodMkLeft _).comap (fun Ï‰ : (Iic n â†’ Î± Ã— R) â†¦ (Ï‰, a, m))
        (by fun_prop) =
      Kernel.const _ (Î½ a) := by ext; simp
  rw [h_eq, condDistrib_congr_left (reward_ae_eq_cond alg Î½ a n m)]
  refine (condDistrib_of_indepFun ?_ (by fun_prop) (by fun_prop)).trans (ae_of_all _ fun Ï‰ â†¦ ?_)
  Â· exact (indepFun_snd_hist_cond alg Î½ a n m).symm
  Â· simp only [Kernel.const_apply]
    have : (fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
          pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰)) â»Â¹' {(a, m)} =
        ({Ï‰ | action alg (n + 1) Ï‰ = a âˆ§
          pullCount (action alg) a (n + 1) Ï‰ = m}).indicator 1 â»Â¹' {1} := by
      ext Ï‰
      simp [Set.indicator_apply]
      grind
    rw [this, cond_of_indepFun, map_snd_apply_arrayMeasure m a]
    Â· exact (indepFun_snd_apply_pullCount_action alg Î½ a m n).symm
    Â· refine Measurable.indicator (by fun_prop) ?_
      exact MeasurableSet.inter ((measurableSet_singleton _).preimage (by fun_prop))
        ((measurableSet_singleton _).preimage (by fun_prop))
    Â· fun_prop
    Â· simp
    Â· convert ham
      ext Ï‰
      simp only [Set.mem_preimage, Set.indicator_apply, Set.mem_setOf_eq, Pi.one_apply,
        Set.mem_singleton_iff, ite_eq_left_iff, not_and, zero_ne_one, imp_false, Classical.not_imp,
        Decidable.not_not, Prod.mk.injEq, and_congr_right_iff]
      intro ha
      simp [ha]

lemma condIndepFun_todo (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (reward alg (n + 1)) âŸ‚áµ¢[(fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
          pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰)),
        Measurable.prodMk (by fun_prop) (measurable_pullCount_action_add_one alg Î½ n);
        arrayMeasure Î½]
      (hist alg Â· n) := by
  have h_cond := hasCondDistrib_reward_hist_action_pullCount alg Î½ n
  refine condIndepFun_of_exists_condDistrib_prod_ae_eq_prodMkLeft (by fun_prop) (by fun_prop) ?_
    h_cond.condDistrib_eq
  exact Measurable.prodMk (by fun_prop) (measurable_pullCount_action_add_one alg Î½ n)

lemma hasCondDistrib_reward' (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (n : â„•) :
    HasCondDistrib (reward alg (n + 1)) (fun Ï‰ â†¦ (hist alg Ï‰ n, action alg (n + 1) Ï‰))
      (Î½.prodMkLeft _) (arrayMeasure Î½) := by
  suffices HasCondDistrib (reward alg (n + 1))
      (fun Ï‰ â†¦ (hist alg Ï‰ n, action alg (n + 1) Ï‰,
        pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰))
      ((Î½.prodMkRight _).prodMkLeft _) (arrayMeasure Î½) by
    sorry
  suffices HasCondDistrib (reward alg (n + 1))
      (fun Ï‰ â†¦ (action alg (n + 1) Ï‰,
        pullCount (action alg) (action alg (n + 1) Ï‰) (n + 1) Ï‰))
      (Î½.prodMkRight _) (arrayMeasure Î½) by
    sorry
  exact hasCondDistrib_reward_pullCount_action alg Î½ n

lemma hasCondDistrib_action (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasCondDistrib (action alg (n + 1))
      (fun Ï‰ (i : Iic n) â†¦ (action alg i Ï‰, reward alg i Ï‰))
      (alg.policy n) (arrayMeasure Î½) := by
  convert hasCondDistrib_action' alg Î½ n with Ï‰ i
  Â· simp only [action]
    rw [hist_eq _ _ n]
  Â· simp only [reward]
    rw [hist_eq _ _ n]

lemma hasCondDistrib_reward (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (n : â„•) :
    HasCondDistrib (reward alg (n + 1))
      (fun Ï‰ â†¦ (fun (i : Iic n) â†¦ (action alg i Ï‰, reward alg i Ï‰), action alg (n + 1) Ï‰))
      ((stationaryEnv Î½).feedback n) (arrayMeasure Î½) := by
  convert hasCondDistrib_reward' alg Î½ n with Ï‰ i
  Â· simp only [action]
    rw [hist_eq _ _ n]
  Â· simp only [reward]
    rw [hist_eq _ _ n]

lemma isAlgEnvSeq_arrayMeasure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    IsAlgEnvSeq (action alg) (reward alg) alg (stationaryEnv Î½) (arrayMeasure Î½) where
  hasLaw_action_zero := hasLaw_action_zero alg Î½
  hasCondDistrib_reward_zero := hasCondDistrib_reward_zero alg Î½
  hasCondDistrib_action := hasCondDistrib_action alg Î½
  hasCondDistrib_reward := hasCondDistrib_reward alg Î½

end ArrayModel

end MeasureSpace

end Bandits
