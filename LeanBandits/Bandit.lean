/-
Copyright (c) 2025 Rémy Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Rémy Degenne, Paulo Rauber
-/
import Mathlib
import LeanBandits.ForMathlib.CondDistrib
import LeanBandits.ForMathlib.KernelCompositionLemmas
import LeanBandits.ForMathlib.Traj

/-!
# Bandit
-/

open MeasureTheory ProbabilityTheory Filter Real Finset

open scoped ENNReal NNReal

namespace Bandits

variable {α R : Type*} {mα : MeasurableSpace α} {mR : MeasurableSpace R}

section MeasureSpace

/-- A stochastic, sequential algorithm. -/
structure Algorithm (α R : Type*) [MeasurableSpace α] [MeasurableSpace R] where
  /-- Policy or sampling rule: distribution of the next pull. -/
  policy : (n : ℕ) → Kernel (Iic n → α × R) α
  [h_policy : ∀ n, IsMarkovKernel (policy n)]
  /-- Distribution of the first pull. -/
  p0 : Measure α
  [hp0 : IsProbabilityMeasure p0]

instance (alg : Algorithm α R) (n : ℕ) : IsMarkovKernel (alg.policy n) := alg.h_policy n
instance (alg : Algorithm α R) : IsProbabilityMeasure alg.p0 := alg.hp0

/-- A deterministic algorithm. -/
noncomputable
def detAlgorithm (nextArm : (n : ℕ) → (Iic n → α × R) → α) (h_next : ∀ n, Measurable (nextArm n))
    (arm0 : α) :
    Algorithm α R where
  policy n := Kernel.deterministic (nextArm n) (h_next n)
  p0 := Measure.dirac arm0

namespace Bandit

/-- Kernel describing the distribution of the next arm-reward pair given the history up to `n`. -/
noncomputable
def stepKernel (alg : Algorithm α R) (ν : Kernel α R) (n : ℕ) : Kernel (Iic n → α × R) (α × R) :=
  (alg.policy n) ⊗ₖ ν.prodMkLeft (Iic n → α × R)

instance (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] (n : ℕ) :
    IsMarkovKernel (stepKernel alg ν n) := by
  rw [stepKernel]
  infer_instance

@[simp]
lemma fst_stepKernel (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] (n : ℕ) :
    (stepKernel alg ν n).fst = alg.policy n := by
  rw [stepKernel, Kernel.fst_compProd]

@[simp]
lemma snd_stepKernel (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] (n : ℕ) :
    (stepKernel alg ν n).snd = ν ∘ₖ alg.policy n := by
  rw [stepKernel, Kernel.snd_compProd_prodMkLeft]

/-- Kernel sending a partial trajectory of the bandit interaction `Iic n → α × ℝ` to a measure
on `ℕ → α × ℝ`, supported on full trajectories that start with the partial one. -/
noncomputable def traj (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] (n : ℕ) :
    Kernel (Iic n → α × R) (ℕ → α × R) :=
  ProbabilityTheory.Kernel.traj (X := fun _ ↦ α × R) (stepKernel alg ν) n
deriving IsMarkovKernel

/-- Measure on the sequence of arms pulled and rewards observed generated by the bandit. -/
noncomputable
def trajMeasure (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] : Measure (ℕ → α × R) :=
  ProbabilityTheory.Kernel.trajMeasure (alg.p0 ⊗ₘ ν) (stepKernel alg ν)
deriving IsProbabilityMeasure

/-- Measure of an infinite stream of rewards from each arm. -/
noncomputable
def streamMeasure (ν : Kernel α R) [IsMarkovKernel ν] : Measure (ℕ → α → R) :=
  Measure.infinitePi fun _ ↦ Measure.infinitePi ν
deriving IsProbabilityMeasure

/-- Joint distribution of the sequence of arm pulled and rewards, and a stream of independent
rewards from all arms. -/
noncomputable
def measure (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] :
    Measure ((ℕ → α × R) × (ℕ → α → R)) :=
  (trajMeasure alg ν).prod (streamMeasure ν)
deriving IsProbabilityMeasure

@[simp]
lemma fst_measure (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] :
    (measure alg ν).fst = trajMeasure alg ν := by
  rw [measure, Measure.fst_prod]

@[simp]
lemma snd_measure (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] :
    (measure alg ν).snd = streamMeasure ν := by
  rw [measure, Measure.snd_prod]

end Bandit

/-- `arm n` is the arm pulled at time `n`. This is a random variable on the measurable space
`ℕ → α × ℝ`. -/
def arm (n : ℕ) (h : ℕ → α × R) : α := (h n).1

/-- `reward n` is the reward at time `n`. This is a random variable on the measurable space
`ℕ → α × R`. -/
def reward (n : ℕ) (h : ℕ → α × R) : R := (h n).2

/-- `hist n` is the history up to time `n`. This is a random variable on the measurable space
`ℕ → α × R`. -/
def hist (n : ℕ) (h : ℕ → α × R) : Iic n → α × R := fun i ↦ h i

@[fun_prop]
lemma measurable_arm (n : ℕ) : Measurable (arm n (α := α) (R := R)) := by unfold arm; fun_prop

@[fun_prop]
lemma measurable_arm_prod : Measurable (fun p : ℕ × (ℕ → α × R) ↦ arm p.1 p.2) := by
  refine measurable_from_prod_countable_right fun n ↦ ?_
  simp only
  fun_prop

@[fun_prop]
lemma measurable_reward (n : ℕ) : Measurable (reward n (α := α) (R := R)) := by
  unfold reward; fun_prop

@[fun_prop]
lemma measurable_reward_prod : Measurable (fun p : ℕ × (ℕ → α × R) ↦ reward p.1 p.2) := by
  refine measurable_from_prod_countable_right fun n ↦ ?_
  simp only
  fun_prop

@[fun_prop]
lemma measurable_hist (n : ℕ) : Measurable (hist n (α := α) (R := R)) := by unfold hist; fun_prop

lemma hist_eq_frestrictLe :
    hist = Preorder.frestrictLe («π» := fun _ ↦ α × R) := by
  ext n h i : 3
  simp [hist, Preorder.frestrictLe]

/-- Filtration of the bandit process. -/
protected def filtration (α R : Type*) [MeasurableSpace α] [MeasurableSpace R] :
    Filtration ℕ (inferInstance : MeasurableSpace (ℕ → α × R)) :=
  MeasureTheory.Filtration.piLE (X := fun _ ↦ α × R)

section Traj

open Kernel Preorder

variable {X : ℕ → Type*} [∀ n, MeasurableSpace (X n)]
    {κ : (n : ℕ) → Kernel ((i : { x // x ∈ Iic n }) → X i) (X (n + 1))} [∀ n, IsMarkovKernel (κ n)]

lemma partialTraj_compProd_eq_traj_map_frestrictLe (a : ℕ) (x₀ : (i : Iic 0) → X i) :
    (partialTraj κ 0 a x₀) ⊗ₘ (κ a) =
      (traj κ 0 x₀).map (fun x ↦ (frestrictLe a x, x (a + 1))) := by
  have h1 := partialTraj_compProd_traj (κ := κ) (zero_le a) x₀
  have h2 : (fun x : Π n, X n ↦ (frestrictLe a x, x (a + 1))) =
      (Prod.map id (fun x ↦ x (a + 1))) ∘ (fun x ↦ (frestrictLe a x, x)) := by ext <;> simp
  rw [h2, ← Measure.map_map (by fun_prop) (by fun_prop), ← h1, ← Measure.compProd_map (by fun_prop)]
  congr
  have : (fun x : Π n, X n ↦ x (a + 1)) =
      (fun x : Π i : Iic (a + 1), X i ↦ x ⟨a+1, by simp⟩) ∘ (frestrictLe (a + 1)) := by ext; simp
  rw [this, map_comp_right _ (by fun_prop) (by fun_prop), traj_map_frestrictLe,
    partialTraj_succ_self, ← map_comp_right _ (by fun_prop) (by fun_prop)]
  have : (fun x : Π i : Iic (a + 1), X i ↦ x ⟨a+1, by simp⟩) ∘ IicProdIoc a (a + 1)
      = (MeasurableEquiv.piSingleton a).symm ∘ Prod.snd := by
    ext; simp [_root_.IicProdIoc, MeasurableEquiv.piSingleton]
  rw [this, map_comp_right _ (by fun_prop) (by fun_prop), ← snd_eq, snd_prod,
    ← map_comp_right _ (by fun_prop) (by fun_prop)]
  simp

lemma traj_cond_lemma1 {a : ℕ} (μ₀ : Measure ((i : Iic 0) → X i)) [IsFiniteMeasure μ₀] :
    (traj κ 0 ∘ₘ μ₀).map (fun x ↦ (frestrictLe a x, x (a + 1)))
      = (traj κ 0 ∘ₘ μ₀).map (frestrictLe a) ⊗ₘ κ a := by
  rw [Measure.compProd_eq_comp_prod, Measure.map_comp _ _ (by fun_prop),
    Measure.map_comp _ _ (by fun_prop), Measure.comp_assoc, traj_map_frestrictLe]
  congr
  ext x₀ : 1
  rw [ProbabilityTheory.Kernel.comp_apply, ← Measure.compProd_eq_comp_prod]
  symm
  rw [Kernel.map_apply _ (by fun_prop)]
  exact partialTraj_compProd_eq_traj_map_frestrictLe a x₀

lemma condDistrib_lemma (μ₀ : Measure ((i : Iic 0) → X i)) [IsFiniteMeasure μ₀] (a : ℕ)
    [Nonempty (X (a + 1))] [StandardBorelSpace (X (a + 1))] :
    condDistrib (fun x ↦ x (a + 1)) (frestrictLe a) (traj κ 0 ∘ₘ μ₀)
      =ᵐ[(traj κ 0 ∘ₘ μ₀).map (frestrictLe a)] κ a := by
  symm
  exact condDistrib_ae_eq_of_measure_eq_compProd (by fun_prop) (by fun_prop) _ (traj_cond_lemma1 μ₀)

lemma traj_zero_map_eval_zero :
    (Kernel.traj κ 0).map (fun h ↦ h 0)
      = Kernel.deterministic (MeasurableEquiv.piIicZero X)
        (MeasurableEquiv.piIicZero X).measurable := by
  suffices (Kernel.traj κ 0).map (fun h ↦ h 0) = (Kernel.partialTraj κ 0 0).map
      (MeasurableEquiv.piIicZero X) by
    rwa [Kernel.partialTraj_zero,
      Kernel.deterministic_map _ (MeasurableEquiv.piIicZero X).measurable] at this
  rw [← Kernel.traj_map_frestrictLe, ← Kernel.map_comp_right _ (by fun_prop) (by fun_prop)]
  congr with h
  sorry

end Traj

lemma condDistrib_arm_reward [StandardBorelSpace α] [Nonempty α] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] (n : ℕ) :
    condDistrib (fun h ↦ (arm (n + 1) h, reward (n + 1) h)) (hist n) (Bandit.trajMeasure alg ν)
      =ᵐ[(Bandit.trajMeasure alg ν).map (hist n)] Bandit.stepKernel alg ν n := by
  exact ProbabilityTheory.Kernel.trajMeasure_condDistrib_ae_eq_kernel

lemma condDistrib_reward [StandardBorelSpace α] [Nonempty α] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] (n : ℕ) :
    condDistrib (reward n) (arm n) (Bandit.trajMeasure alg ν)
      =ᵐ[(Bandit.trajMeasure alg ν).map (arm n)] ν := by
  cases n with
  | zero => sorry
  | succ n =>
    have h_ar := condDistrib_arm_reward alg ν n
    have h_prod := condDistrib_prod_left (X := arm (n + 1)) (Y := reward (n + 1))
      (T := hist n) (μ := Bandit.trajMeasure alg ν) (by fun_prop) (by fun_prop) (by fun_prop)
    sorry

lemma condDistrib_arm [StandardBorelSpace α] [Nonempty α] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] (n : ℕ) :
    condDistrib (arm (n + 1)) (hist n) (Bandit.trajMeasure alg ν)
      =ᵐ[(Bandit.trajMeasure alg ν).map (hist n)] alg.policy n := by
  sorry

lemma hasLaw_step_zero
    (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] :
    HasLaw (fun h : ℕ → α × R ↦ h 0) (alg.p0 ⊗ₘ ν) (Bandit.trajMeasure alg ν) where
  aemeasurable := Measurable.aemeasurable (by fun_prop)
  map_eq := by
    simp only [Bandit.trajMeasure, ProbabilityTheory.Kernel.trajMeasure]
    rw [← Measure.deterministic_comp_eq_map (by fun_prop), Measure.comp_assoc,
      Kernel.deterministic_comp_eq_map, traj_zero_map_eval_zero,
      Measure.deterministic_comp_eq_map, Measure.map_map (by fun_prop) (by fun_prop)]
    simp

lemma hasLaw_arm_zero [StandardBorelSpace α] [Nonempty α] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm α R) (ν : Kernel α R) [IsMarkovKernel ν] :
    HasLaw (arm 0) alg.p0 (Bandit.trajMeasure alg ν) where
  map_eq := by
    sorry

/-- The reward at time `n+1` is independent of the history up to time `n` given the arm at `n+1`. -/
lemma condIndepFun_reward_hist_arm [StandardBorelSpace α] [Nonempty α]
    [StandardBorelSpace R] [Nonempty R]
    {alg : Algorithm α R} {ν : Kernel α R} [IsMarkovKernel ν] (n : ℕ) :
    CondIndepFun (MeasurableSpace.comap (arm (n + 1)) inferInstance)
      (measurable_arm _).comap_le (reward (n + 1)) (hist n) (Bandit.trajMeasure alg ν) := by
  rw [condIndepFun_iff_condDistrib_prod_ae_eq_prodMkLeft (by fun_prop) (by fun_prop) (by fun_prop)]
  sorry

section DetAlgorithm

variable [StandardBorelSpace α] [Nonempty α] [StandardBorelSpace R] [Nonempty R]
  {nextArm : (n : ℕ) → (Iic n → α × R) → α} {h_next : ∀ n, Measurable (nextArm n)}
  {arm0 : α} {ν : Kernel α R} [IsMarkovKernel ν]

lemma HasLaw_arm_zero_detAlgorithm :
    HasLaw (arm 0) (Measure.dirac arm0)
      (Bandit.trajMeasure (detAlgorithm nextArm h_next arm0) ν) where
  map_eq := (hasLaw_arm_zero _ _).map_eq

lemma arm_zero_detAlgorithm :
    arm 0 =ᵐ[Bandit.trajMeasure (detAlgorithm nextArm h_next arm0) ν] fun _ ↦ arm0 := by
  have h_eq : ∀ᵐ x ∂((Bandit.trajMeasure (detAlgorithm nextArm h_next arm0) ν).map (arm 0)), x
      = arm0 := by
    rw [(hasLaw_arm_zero _ _).map_eq]
    simp [detAlgorithm]
  exact ae_of_ae_map (by fun_prop) h_eq

lemma arm_detAlgorithm_ae_eq (n : ℕ) :
    arm (n + 1) =ᵐ[Bandit.trajMeasure (detAlgorithm nextArm h_next arm0) ν]
      fun h ↦ nextArm n (fun i ↦ h i) := by
  sorry

example : ∀ᵐ h ∂(Bandit.trajMeasure (detAlgorithm nextArm h_next arm0) ν),
    arm 0 h = arm0 ∧ ∀ n, arm (n + 1) h = nextArm n (fun i ↦ h i) := by
  rw [eventually_and, ae_all_iff]
  exact ⟨arm_zero_detAlgorithm, arm_detAlgorithm_ae_eq⟩

end DetAlgorithm

end MeasureSpace

end Bandits
