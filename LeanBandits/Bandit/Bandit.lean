/-
Copyright (c) 2025 RÃ©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: RÃ©my Degenne, Paulo Rauber
-/
import LeanBandits.SequentialLearning.Deterministic
import Mathlib.Probability.IdentDistrib
import Mathlib.Probability.Independence.InfinitePi

/-!
# Bandit
-/

open MeasureTheory ProbabilityTheory Filter Real Finset Learning

open scoped ENNReal NNReal

namespace Bandits

variable {Î± R : Type*} {mÎ± : MeasurableSpace Î±} {mR : MeasurableSpace R}

section MeasureSpace

namespace Bandit

/-- Kernel describing the distribution of the next arm-reward pair given the history up to `n`. -/
noncomputable
def stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    Kernel (Iic n â†’ Î± Ã— R) (Î± Ã— R) :=
  Learning.stepKernel alg (stationaryEnv Î½) n
deriving IsMarkovKernel

@[simp]
lemma fst_stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (stepKernel alg Î½ n).fst = alg.policy n := by
  rw [stepKernel, Learning.fst_stepKernel]

@[simp]
lemma snd_stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (stepKernel alg Î½ n).snd = Î½ âˆ˜â‚– alg.policy n := by
  rw [stepKernel, Learning.stepKernel, stationaryEnv_feedback, Kernel.snd_compProd_prodMkLeft]

/-- Measure on the sequence of arms pulled and rewards observed generated by the bandit. -/
noncomputable
def trajMeasure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : Measure (â„• â†’ Î± Ã— R) :=
  Kernel.trajMeasure (alg.p0 âŠ—â‚˜ Î½) (stepKernel alg Î½)
deriving IsProbabilityMeasure

/-- Measure of an infinite stream of rewards from each arm. -/
noncomputable
def streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : Measure (â„• â†’ Î± â†’ R) :=
  Measure.infinitePi fun _ â†¦ Measure.infinitePi Î½
deriving IsProbabilityMeasure

/-- Joint distribution of the sequence of arm pulled and rewards, and a stream of independent
rewards from all arms. -/
noncomputable
def measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    Measure ((â„• â†’ Î± Ã— R) Ã— (â„• â†’ Î± â†’ R)) :=
  (trajMeasure alg Î½).prod (streamMeasure Î½)
deriving IsProbabilityMeasure

@[simp]
lemma fst_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    (measure alg Î½).fst = trajMeasure alg Î½ := by
  rw [measure, Measure.fst_prod]

@[simp]
lemma snd_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    (measure alg Î½).snd = streamMeasure Î½ := by
  rw [measure, Measure.snd_prod]

end Bandit

section StreamMeasure

lemma _root_.hasLaw_eval_infinitePi {Î¹ : Type*} {X : Î¹ â†’ Type*} {mX : âˆ€ i, MeasurableSpace (X i)}
  (Î¼ : (i : Î¹) â†’ Measure (X i)) [hÎ¼ : âˆ€ i, IsProbabilityMeasure (Î¼ i)] (i : Î¹) :
    HasLaw (Function.eval i) (Î¼ i) (Measure.infinitePi Î¼) where
  aemeasurable := Measurable.aemeasurable (by fun_prop)
  map_eq := by exact (measurePreserving_eval_infinitePi Î¼ i).map_eq

lemma hasLaw_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasLaw (fun h : â„• â†’ Î± â†’ R â†¦ h n) (Measure.infinitePi Î½) (Bandit.streamMeasure Î½) :=
  hasLaw_eval_infinitePi (fun _ â†¦ Measure.infinitePi Î½) n

lemma hasLaw_eval_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    HasLaw (fun h : â„• â†’ Î± â†’ R â†¦ h n a) (Î½ a) (Bandit.streamMeasure Î½) :=
  (hasLaw_eval_infinitePi Î½ a).comp (hasLaw_eval_streamMeasure Î½ n)

lemma identDistrib_eval_eval_id_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    IdentDistrib (fun h : â„• â†’ Î± â†’ R â†¦ h n a) id (Bandit.streamMeasure Î½) (Î½ a) where
  aemeasurable_fst := Measurable.aemeasurable (by fun_prop)
  aemeasurable_snd := Measurable.aemeasurable (by fun_prop)
  map_eq := by
    rw [â† (hasLaw_eval_eval_streamMeasure Î½ n a).map_eq,
      Measure.map_map (by fun_prop) (by fun_prop)]
    simp

lemma Integrable.congr_identDistrib {Î© Î©' : Type*}
    {mÎ© : MeasurableSpace Î©} {mÎ©' : MeasurableSpace Î©'}
    {Î¼ : Measure Î©} {Î¼' : Measure Î©'} {X : Î© â†’ â„} {Y : Î©' â†’ â„}
    (hX : Integrable X Î¼) (hXY : IdentDistrib X Y Î¼ Î¼') :
    Integrable Y Î¼' := by
  have hX' : Integrable id (Î¼.map X) := by
    rwa [integrable_map_measure (by fun_prop) hXY.aemeasurable_fst]
  rw [hXY.map_eq] at hX'
  rwa [integrable_map_measure (by fun_prop) hXY.aemeasurable_snd] at hX'

lemma integrable_eval_streamMeasure (Î½ : Kernel Î± â„) [IsMarkovKernel Î½] (n : â„•) (a : Î±)
    (h_int : Integrable id (Î½ a)) :
    Integrable (fun h : â„• â†’ Î± â†’ â„ â†¦ h n a) (Bandit.streamMeasure Î½) :=
  Integrable.congr_identDistrib h_int (identDistrib_eval_eval_id_streamMeasure Î½ n a).symm

lemma integral_eval_streamMeasure (Î½ : Kernel Î± â„) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    âˆ« h, h n a âˆ‚(Bandit.streamMeasure Î½) = (Î½ a)[id] := by
  calc âˆ« h, h n a âˆ‚(Bandit.streamMeasure Î½)
  _ = âˆ« x, x âˆ‚((Bandit.streamMeasure Î½).map (fun h â†¦ h n a)) := by
    rw [integral_map (Measurable.aemeasurable (by fun_prop)) (by fun_prop)]
  _ = (Î½ a)[id] := by simp [(hasLaw_eval_eval_streamMeasure Î½ n a).map_eq]

lemma iIndepFun_eval_streamMeasure' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    iIndepFun (fun n Ï‰ â†¦ Ï‰ n) (Bandit.streamMeasure Î½) :=
  iIndepFun_infinitePi (Î¼ := fun (_ : â„•) â†¦ Measure.infinitePi Î½) (Î© := fun _ â†¦ Î± â†’ R)
    (X := fun i u â†¦ u) (fun i â†¦ by fun_prop)

lemma iIndepFun_eval_streamMeasure'' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) :
    iIndepFun (fun n Ï‰ â†¦ Ï‰ n a) (Bandit.streamMeasure Î½) :=
  (iIndepFun_eval_streamMeasure' Î½).comp (g := fun i Ï‰ â†¦ Ï‰ a) (by fun_prop)

lemma iIndepFun_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    iIndepFun (fun (p : â„• Ã— Î±) Ï‰ â†¦ Ï‰ p.1 p.2) (Bandit.streamMeasure Î½) := by
  have h_ind := iIndepFun_eval_streamMeasure' Î½
  sorry -- essentially done by Etienne in Mathlib PRs

lemma indepFun_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] {n m : â„•} {a b : Î±}
    (h : n â‰  m âˆ¨ a â‰  b) :
    IndepFun (fun Ï‰ â†¦ Ï‰ n a) (fun Ï‰ â†¦ Ï‰ m b) (Bandit.streamMeasure Î½) := by
  change IndepFun (fun Ï‰ â†¦ Ï‰ (n, a).1 (n, a).2) (fun Ï‰ â†¦ Ï‰ (m, b).1 (m, b).2)
    (Bandit.streamMeasure Î½)
  exact (iIndepFun_eval_streamMeasure Î½).indepFun (by grind)

lemma indepFun_eval_streamMeasure' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] {a b : Î±} (h : a â‰  b) :
    IndepFun (fun Ï‰ n â†¦ Ï‰ n a) (fun Ï‰ n â†¦ Ï‰ n b) (Bandit.streamMeasure Î½) := by
  sorry

lemma indepFun_eval_snd_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    {a b : Î±} (h : a â‰  b) :
    IndepFun (fun Ï‰ n â†¦ Ï‰.2 n a) (fun Ï‰ n â†¦ Ï‰.2 n b) (Bandit.measure alg Î½) := by
  refine indepFun_snd_prod ?_ ?_ (indepFun_eval_streamMeasure' Î½ h) (Bandit.trajMeasure alg Î½)
  Â· exact Measurable.aemeasurable (by fun_prop)
  Â· exact Measurable.aemeasurable (by fun_prop)

end StreamMeasure

/-- `arm n` is the arm pulled at time `n`. This is a random variable on the measurable space
`â„• â†’ Î± Ã— â„`. -/
def arm (n : â„•) (h : â„• â†’ Î± Ã— R) : Î± := (h n).1

/-- `reward n` is the reward at time `n`. This is a random variable on the measurable space
`â„• â†’ Î± Ã— R`. -/
def reward (n : â„•) (h : â„• â†’ Î± Ã— R) : R := (h n).2

/-- `hist n` is the history up to time `n`. This is a random variable on the measurable space
`â„• â†’ Î± Ã— R`. -/
def hist (n : â„•) (h : â„• â†’ Î± Ã— R) : Iic n â†’ Î± Ã— R := fun i â†¦ h i

@[fun_prop]
lemma measurable_arm (n : â„•) : Measurable (arm n (Î± := Î±) (R := R)) := measurable_action n

@[fun_prop]
lemma measurable_arm_prod : Measurable (fun p : â„• Ã— (â„• â†’ Î± Ã— R) â†¦ arm p.1 p.2) :=
  measurable_action_prod

@[fun_prop]
lemma measurable_reward (n : â„•) : Measurable (reward n (Î± := Î±) (R := R)) :=
  Learning.measurable_reward n

@[fun_prop]
lemma measurable_reward_prod : Measurable (fun p : â„• Ã— (â„• â†’ Î± Ã— R) â†¦ reward p.1 p.2) :=
  Learning.measurable_reward_prod

@[fun_prop]
lemma measurable_hist (n : â„•) : Measurable (hist n (Î± := Î±) (R := R)) :=
  Learning.measurable_hist n

lemma hist_eq_frestrictLe :
    hist = Preorder.frestrictLe (Â«Ï€Â» := fun _ â†¦ Î± Ã— R) := by
  ext n h i : 3
  simp [hist, Preorder.frestrictLe]

/-- Filtration of the bandit process. -/
protected def filtration (Î± R : Type*) [MeasurableSpace Î±] [MeasurableSpace R] :
    Filtration â„• (inferInstance : MeasurableSpace (â„• â†’ Î± Ã— R)) :=
  MeasureTheory.Filtration.piLE (X := fun _ â†¦ Î± Ã— R)

section Laws

lemma hasLaw_step_zero (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    HasLaw (fun h : â„• â†’ Î± Ã— R â†¦ h 0) (alg.p0 âŠ—â‚˜ Î½) (Bandit.trajMeasure alg Î½) :=
  Learning.hasLaw_step_zero alg (stationaryEnv Î½)

lemma hasLaw_arm_zero (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    HasLaw (arm 0) alg.p0 (Bandit.trajMeasure alg Î½) :=
  Learning.hasLaw_action_zero alg (stationaryEnv Î½)

lemma condDistrib_arm_reward [StandardBorelSpace Î±] [Nonempty Î±] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    condDistrib (fun h â†¦ (arm (n + 1) h, reward (n + 1) h)) (hist n) (Bandit.trajMeasure alg Î½)
      =áµ[(Bandit.trajMeasure alg Î½).map (hist n)] Bandit.stepKernel alg Î½ n :=
  Learning.condDistrib_step alg (stationaryEnv Î½) n

lemma condDistrib_reward' [StandardBorelSpace Î±] [Nonempty Î±] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    condDistrib (reward (n + 1)) (fun Ï‰ â†¦ (hist n Ï‰, arm (n + 1) Ï‰)) (Bandit.trajMeasure alg Î½)
      =áµ[(Bandit.trajMeasure alg Î½).map (fun Ï‰ â†¦ (hist n Ï‰, arm (n + 1) Ï‰))] Î½.prodMkLeft _ :=
  Learning.condDistrib_reward alg (stationaryEnv Î½) n

lemma condDistrib_reward [StandardBorelSpace Î±] [Nonempty Î±] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    condDistrib (reward n) (arm n) (Bandit.trajMeasure alg Î½)
      =áµ[(Bandit.trajMeasure alg Î½).map (arm n)] Î½ :=
   Learning.condDistrib_reward_stationaryEnv n

lemma condDistrib_arm [StandardBorelSpace Î±] [Nonempty Î±] [StandardBorelSpace R] [Nonempty R]
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    condDistrib (arm (n + 1)) (hist n) (Bandit.trajMeasure alg Î½)
      =áµ[(Bandit.trajMeasure alg Î½).map (hist n)] alg.policy n :=
  Learning.condDistrib_action alg (stationaryEnv Î½) n

/-- The reward at time `n+1` is independent of the history up to time `n` given the arm at `n+1`. -/
lemma condIndepFun_reward_hist_arm [StandardBorelSpace Î±] [Nonempty Î±]
    [StandardBorelSpace R] [Nonempty R]
    {alg : Algorithm Î± R} {Î½ : Kernel Î± R} [IsMarkovKernel Î½] (n : â„•) :
    CondIndepFun (MeasurableSpace.comap (arm (n + 1)) inferInstance)
      (measurable_arm _).comap_le (reward (n + 1)) (hist n) (Bandit.trajMeasure alg Î½) :=
  Learning.condIndepFun_reward_hist_action n

end Laws

section DetAlgorithm

variable {nextArm : (n : â„•) â†’ (Iic n â†’ Î± Ã— R) â†’ Î±} {h_next : âˆ€ n, Measurable (nextArm n)}
  {arm0 : Î±} {Î½ : Kernel Î± R} [IsMarkovKernel Î½]

local notation "ğ”“t" => Bandit.trajMeasure (detAlgorithm nextArm h_next arm0) Î½

lemma HasLaw_arm_zero_detAlgorithm : HasLaw (arm 0) (Measure.dirac arm0) ğ”“t where
  map_eq := (hasLaw_arm_zero _ _).map_eq

lemma arm_zero_detAlgorithm [MeasurableSingletonClass Î±] :
    arm 0 =áµ[ğ”“t] fun _ â†¦ arm0 := by
  have h_eq : âˆ€áµ x âˆ‚(((ğ”“t).map (arm 0))), x = arm0 := by
    rw [(hasLaw_arm_zero _ _).map_eq]
    simp [detAlgorithm]
  exact ae_of_ae_map (by fun_prop) h_eq

lemma arm_detAlgorithm_ae_eq [StandardBorelSpace Î±] [Nonempty Î±]
    [StandardBorelSpace R] [Nonempty R] (n : â„•) :
    arm (n + 1) =áµ[ğ”“t] fun h â†¦ nextArm n (fun i â†¦ h i) :=
  Learning.action_detAlgorithm_ae_eq n

example [StandardBorelSpace Î±] [Nonempty Î±]
    [StandardBorelSpace R] [Nonempty R] :
    âˆ€áµ h âˆ‚(ğ”“t), arm 0 h = arm0 âˆ§ âˆ€ n, arm (n + 1) h = nextArm n (fun i â†¦ h i) := by
  rw [eventually_and, ae_all_iff]
  exact âŸ¨arm_zero_detAlgorithm, arm_detAlgorithm_ae_eqâŸ©

end DetAlgorithm

end MeasureSpace

end Bandits
