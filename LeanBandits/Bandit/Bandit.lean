/-
Copyright (c) 2025 RÃ©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: RÃ©my Degenne, Paulo Rauber
-/
import LeanBandits.ForMathlib.IndepInfinitePi
import LeanBandits.SequentialLearning.Deterministic
import LeanBandits.SequentialLearning.StationaryEnv
import LeanBandits.SequentialLearning.FiniteActions
import Mathlib.Probability.IdentDistrib
import Mathlib.MeasureTheory.Constructions.UnitInterval

/-!
# Bandit
-/

open MeasureTheory ProbabilityTheory Filter Real Finset Learning

open scoped ENNReal NNReal

namespace Bandits

variable {Î± R : Type*} {mÎ± : MeasurableSpace Î±} {mR : MeasurableSpace R}

section MeasureSpace

namespace Bandit

/-- Kernel describing the distribution of the next action-reward pair given the history up to
time `n`. -/
noncomputable
def stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    Kernel (Iic n â†’ Î± Ã— R) (Î± Ã— R) :=
  Learning.stepKernel alg (stationaryEnv Î½) n
deriving IsMarkovKernel

@[simp]
lemma fst_stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (stepKernel alg Î½ n).fst = alg.policy n := by
  rw [stepKernel, Learning.fst_stepKernel]

@[simp]
lemma snd_stepKernel (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    (stepKernel alg Î½ n).snd = Î½ âˆ˜â‚– alg.policy n := by
  rw [stepKernel, Learning.stepKernel, stationaryEnv_feedback, Kernel.snd_compProd_prodMkLeft]

/-- Measure on the sequence of actions pulled and rewards observed generated by the bandit. -/
noncomputable
def trajMeasure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : Measure (â„• â†’ Î± Ã— R) :=
  Learning.trajMeasure alg (stationaryEnv Î½)
deriving IsProbabilityMeasure

/-- Measure of an infinite stream of rewards from each action. -/
noncomputable
def streamMeasure (Î½ : Kernel Î± R) : Measure (â„• â†’ Î± â†’ R) :=
  Measure.infinitePi fun _ â†¦ Measure.infinitePi Î½

instance (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : IsProbabilityMeasure (streamMeasure Î½) := by
  unfold streamMeasure
  infer_instance

/-- Joint distribution of the sequence of action pulled and rewards, and a stream of independent
rewards from all actions. -/
noncomputable
def measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    Measure ((â„• â†’ Î± Ã— R) Ã— (â„• â†’ Î± â†’ R)) :=
  (trajMeasure alg Î½).prod (streamMeasure Î½)
deriving IsProbabilityMeasure

@[simp]
lemma fst_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    (measure alg Î½).fst = trajMeasure alg Î½ := by
  rw [measure, Measure.fst_prod]

@[simp]
lemma snd_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    (measure alg Î½).snd = streamMeasure Î½ := by
  rw [measure, Measure.snd_prod]

end Bandit

section StreamMeasure

lemma _root_.hasLaw_eval_infinitePi {Î¹ : Type*} {X : Î¹ â†’ Type*} {mX : âˆ€ i, MeasurableSpace (X i)}
  (Î¼ : (i : Î¹) â†’ Measure (X i)) [hÎ¼ : âˆ€ i, IsProbabilityMeasure (Î¼ i)] (i : Î¹) :
    HasLaw (Function.eval i) (Î¼ i) (Measure.infinitePi Î¼) where
  aemeasurable := Measurable.aemeasurable (by fun_prop)
  map_eq := by exact (measurePreserving_eval_infinitePi Î¼ i).map_eq

lemma hasLaw_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasLaw (fun h : â„• â†’ Î± â†’ R â†¦ h n) (Measure.infinitePi Î½) (Bandit.streamMeasure Î½) :=
  hasLaw_eval_infinitePi (fun _ â†¦ Measure.infinitePi Î½) n

lemma hasLaw_eval_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    HasLaw (fun h : â„• â†’ Î± â†’ R â†¦ h n a) (Î½ a) (Bandit.streamMeasure Î½) :=
  (hasLaw_eval_infinitePi Î½ a).comp (hasLaw_eval_streamMeasure Î½ n)

lemma identDistrib_eval_eval_id_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    IdentDistrib (fun h : â„• â†’ Î± â†’ R â†¦ h n a) id (Bandit.streamMeasure Î½) (Î½ a) where
  aemeasurable_fst := Measurable.aemeasurable (by fun_prop)
  aemeasurable_snd := Measurable.aemeasurable (by fun_prop)
  map_eq := by
    rw [â† (hasLaw_eval_eval_streamMeasure Î½ n a).map_eq,
      Measure.map_map (by fun_prop) (by fun_prop)]
    simp

lemma Integrable.congr_identDistrib {Î© Î©' : Type*}
    {mÎ© : MeasurableSpace Î©} {mÎ©' : MeasurableSpace Î©'}
    {Î¼ : Measure Î©} {Î¼' : Measure Î©'} {X : Î© â†’ â„} {Y : Î©' â†’ â„}
    (hX : Integrable X Î¼) (hXY : IdentDistrib X Y Î¼ Î¼') :
    Integrable Y Î¼' := by
  have hX' : Integrable id (Î¼.map X) := by
    rwa [integrable_map_measure (by fun_prop) hXY.aemeasurable_fst]
  rw [hXY.map_eq] at hX'
  rwa [integrable_map_measure (by fun_prop) hXY.aemeasurable_snd] at hX'

lemma integrable_eval_streamMeasure (Î½ : Kernel Î± â„) [IsMarkovKernel Î½] (n : â„•) (a : Î±)
    (h_int : Integrable id (Î½ a)) :
    Integrable (fun h : â„• â†’ Î± â†’ â„ â†¦ h n a) (Bandit.streamMeasure Î½) :=
  Integrable.congr_identDistrib h_int (identDistrib_eval_eval_id_streamMeasure Î½ n a).symm

lemma integral_eval_streamMeasure (Î½ : Kernel Î± â„) [IsMarkovKernel Î½] (n : â„•) (a : Î±) :
    âˆ« h, h n a âˆ‚(Bandit.streamMeasure Î½) = (Î½ a)[id] := by
  calc âˆ« h, h n a âˆ‚(Bandit.streamMeasure Î½)
  _ = âˆ« x, x âˆ‚((Bandit.streamMeasure Î½).map (fun h â†¦ h n a)) := by
    rw [integral_map (Measurable.aemeasurable (by fun_prop)) (by fun_prop)]
  _ = (Î½ a)[id] := by simp [(hasLaw_eval_eval_streamMeasure Î½ n a).map_eq]

lemma iIndepFun_eval_streamMeasure' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    iIndepFun (fun n Ï‰ â†¦ Ï‰ n) (Bandit.streamMeasure Î½) :=
  iIndepFun_infinitePi (P := fun (_ : â„•) â†¦ Measure.infinitePi Î½) (Î© := fun _ â†¦ Î± â†’ R)
    (X := fun i u â†¦ u) (fun i â†¦ by fun_prop)

lemma iIndepFun_eval_streamMeasure'' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (a : Î±) :
    iIndepFun (fun n Ï‰ â†¦ Ï‰ n a) (Bandit.streamMeasure Î½) :=
  (iIndepFun_eval_streamMeasure' Î½).comp (g := fun i Ï‰ â†¦ Ï‰ a) (by fun_prop)

lemma iIndepFun_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    iIndepFun (fun (p : â„• Ã— Î±) Ï‰ â†¦ Ï‰ p.1 p.2) (Bandit.streamMeasure Î½) :=
  iIndepFun_uncurry_infinitePi' (X := fun _ _ â†¦ id) (fun _ â†¦ Î½) (by fun_prop)

lemma indepFun_eval_streamMeasure (Î½ : Kernel Î± R) [IsMarkovKernel Î½] {n m : â„•} {a b : Î±}
    (h : n â‰  m âˆ¨ a â‰  b) :
    IndepFun (fun Ï‰ â†¦ Ï‰ n a) (fun Ï‰ â†¦ Ï‰ m b) (Bandit.streamMeasure Î½) := by
  change IndepFun (fun Ï‰ â†¦ Ï‰ (n, a).1 (n, a).2) (fun Ï‰ â†¦ Ï‰ (m, b).1 (m, b).2)
    (Bandit.streamMeasure Î½)
  exact (iIndepFun_eval_streamMeasure Î½).indepFun (by grind)

lemma indepFun_eval_streamMeasure' (Î½ : Kernel Î± R) [IsMarkovKernel Î½] {a b : Î±} (h : a â‰  b) :
    IndepFun (fun Ï‰ n â†¦ Ï‰ n a) (fun Ï‰ n â†¦ Ï‰ n b) (Bandit.streamMeasure Î½) :=
  indepFun_proj_infinitePi_infinitePi h

lemma indepFun_eval_snd_measure (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    {a b : Î±} (h : a â‰  b) :
    IndepFun (fun Ï‰ n â†¦ Ï‰.2 n a) (fun Ï‰ n â†¦ Ï‰.2 n b) (Bandit.measure alg Î½) := by
  refine indepFun_snd_prod ?_ ?_ (indepFun_eval_streamMeasure' Î½ h) (Bandit.trajMeasure alg Î½)
  Â· exact Measurable.aemeasurable (by fun_prop)
  Â· exact Measurable.aemeasurable (by fun_prop)

end StreamMeasure

section DetAlgorithm

variable {nextaction : (n : â„•) â†’ (Iic n â†’ Î± Ã— R) â†’ Î±} {h_next : âˆ€ n, Measurable (nextaction n)}
  {action0 : Î±} {Î½ : Kernel Î± R} [IsMarkovKernel Î½]

local notation "ð”“t" => Bandit.trajMeasure (detAlgorithm nextaction h_next action0) Î½

lemma HasLaw_action_zero_detAlgorithm : HasLaw (IT.action 0) (Measure.dirac action0) ð”“t where
  map_eq := (IT.hasLaw_action_zero _ _).map_eq

lemma action_zero_detAlgorithm [MeasurableSingletonClass Î±] :
    IT.action 0 =áµ[ð”“t] fun _ â†¦ action0 :=
  IT.action_zero_detAlgorithm

lemma action_detAlgorithm_ae_eq [StandardBorelSpace Î±] [Nonempty Î±]
    [StandardBorelSpace R] [Nonempty R] (n : â„•) :
    IT.action (n + 1) =áµ[ð”“t] fun h â†¦ nextaction n (fun i â†¦ h i) :=
  IT.action_detAlgorithm_ae_eq n

example [StandardBorelSpace Î±] [Nonempty Î±]
    [StandardBorelSpace R] [Nonempty R] :
    âˆ€áµ h âˆ‚(ð”“t), IT.action 0 h = action0 âˆ§
      âˆ€ n, IT.action (n + 1) h = nextaction n (fun i â†¦ h i) := by
  rw [eventually_and, ae_all_iff]
  exact âŸ¨action_zero_detAlgorithm, action_detAlgorithm_ae_eqâŸ©

end DetAlgorithm

namespace ArrayModel

open unitInterval

section Aux

-- from Mathlib PR #30112
theorem representation {Î± Î² : Type*} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²}
    [Nonempty Î²] [StandardBorelSpace Î²]
    (Îº : Kernel Î± Î²) [IsMarkovKernel Îº] :
    âˆƒ (f : Î± â†’ I â†’ Î²), Measurable (Function.uncurry f) âˆ§ âˆ€ a, volume.map (f a) = Îº a := sorry

theorem representation_measure {Î² : Type*} {mÎ² : MeasurableSpace Î²}
    [Nonempty Î²] [StandardBorelSpace Î²]
    (Î¼ : Measure Î²) [IsProbabilityMeasure Î¼] :
    âˆƒ (f : I â†’ Î²), Measurable f âˆ§ volume.map f = Î¼ := by
  obtain âŸ¨f, hf_meas, hf_mapâŸ© := representation (Kernel.const Unit Î¼)
  specialize hf_map âŸ¨âŸ©
  exact âŸ¨f âŸ¨âŸ©, by fun_prop, by simpaâŸ©

end Aux

variable (Î± R) in
def probSpace : Type _ := (â„• â†’ I) Ã— (â„• â†’ Î± â†’ R)

instance {Î± R : Type*} [MeasurableSpace R] : MeasurableSpace (probSpace Î± R) :=
  inferInstanceAs (MeasurableSpace ((â„• â†’ I) Ã— (â„• â†’ Î± â†’ R)))

noncomputable
def arrayMeasure (Î½ : Kernel Î± R) : Measure (probSpace Î± R) :=
  (Measure.infinitePi fun _ â†¦ volume).prod (Bandit.streamMeasure Î½)

instance (Î½ : Kernel Î± R) [IsMarkovKernel Î½] : IsProbabilityMeasure (arrayMeasure Î½) :=
  Measure.prod.instIsProbabilityMeasure _ _

variable [Nonempty Î±] [StandardBorelSpace Î±]

noncomputable
def initAlgFunction (alg : Algorithm Î± R) : I â†’ Î± :=
  (representation_measure alg.p0).choose

lemma initAlgFunction_map (alg : Algorithm Î± R) : volume.map (initAlgFunction alg) = alg.p0 :=
  (representation_measure alg.p0).choose_spec.2

@[fun_prop]
lemma measurable_initAlgFunction (alg : Algorithm Î± R) :
    Measurable (initAlgFunction alg) := (representation_measure alg.p0).choose_spec.1

noncomputable
def algFunction (alg : Algorithm Î± R) (n : â„•) :
    (Iic n â†’ Î± Ã— R) â†’ I â†’ Î± :=
  (representation (alg.policy n)).choose

lemma algFunction_map (alg : Algorithm Î± R) (n : â„•) (h : Iic n â†’ Î± Ã— R) :
      volume.map (algFunction alg n h) = alg.policy n h :=
  (representation (alg.policy n)).choose_spec.2 h

@[fun_prop]
lemma measurable_algFunction (alg : Algorithm Î± R) (n : â„•) :
    Measurable (Function.uncurry (algFunction alg n)) :=
  (representation (alg.policy n)).choose_spec.1

noncomputable
def hist [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) : (n : â„•) â†’ Iic n â†’ Î± Ã— R
| 0 => fun _ â†¦ (initAlgFunction alg (Ï‰.1 0), Ï‰.2 0 (initAlgFunction alg (Ï‰.1 0)))
| n + 1 =>
  let hn : Iic n â†’ Î± Ã— R := hist alg Ï‰ n
  let a : Î± := algFunction alg n hn (Ï‰.1 (n + 1))
  fun i â†¦ if hin : i â‰¤ n then hn âŸ¨i, by simp [hin]âŸ© else (a, Ï‰.2 (pullCount' n hn a) a)

@[simp]
lemma hist_zero [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) :
    hist alg Ï‰ 0 = fun _ â†¦ (initAlgFunction alg (Ï‰.1 0), Ï‰.2 0 (initAlgFunction alg (Ï‰.1 0))) :=
  rfl

lemma hist_add_one [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) (n : â„•) :
    let a : Î± := algFunction alg n (hist alg Ï‰ n) (Ï‰.1 (n + 1))
    hist alg Ï‰ (n + 1) =
      fun (i : Iic (n + 1)) â†¦ if hin : i â‰¤ n then hist alg Ï‰ n âŸ¨i, by simp [hin]âŸ©
        else (a, Ï‰.2 (pullCount' n (hist alg Ï‰ n) a) a) :=
  rfl

lemma hist_eq [DecidableEq Î±] (alg : Algorithm Î± R) (Ï‰ : probSpace Î± R) (n : â„•) :
    hist alg Ï‰ n = fun i : Iic n â†¦ hist alg Ï‰ i âŸ¨i.1, by simpâŸ© := by
  induction n with
  | zero =>
    ext i : 1
    simp only [hist]
    sorry
  | succ n hn =>
    ext i : 1
    by_cases hin : i â‰¤ n
    Â· rw [hist_add_one]
      simp only [hin, â†“reduceDIte]
      rw [funext_iff] at hn
      simp_rw [hn]
    Â· grind

@[fun_prop]
lemma measurable_hist [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    Measurable (fun Ï‰ â†¦ hist alg Ï‰ n) := by
  induction n with
  | zero =>
    simp_rw [hist_zero, measurable_pi_iff]
    refine fun _ â†¦ Measurable.prodMk (by fun_prop) ?_
    sorry
  | succ n hn =>
    refine measurable_pi_iff.mpr fun i â†¦ ?_
    by_cases hin : i â‰¤ n
    Â· simp only [hist, hin, â†“reduceDIte]
      rw [measurable_pi_iff] at hn
      exact hn âŸ¨i.1, by simp [hin]âŸ©
    Â· simp only [hist, hin, â†“reduceDIte]
      refine Measurable.prodMk (by fun_prop) ?_
      sorry

noncomputable
def action [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) (Ï‰ : probSpace Î± R) : Î± :=
  (hist alg Ï‰ n âŸ¨n, by simpâŸ©).1

lemma action_zero [DecidableEq Î±] (alg : Algorithm Î± R) :
    action alg 0 = fun Ï‰ â†¦ initAlgFunction alg (Ï‰.1 0) := by
  ext
  simp [action, hist_zero]

lemma action_add_one_eq [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    action alg (n + 1) = fun Ï‰ â†¦ algFunction alg n (hist alg Ï‰ n) (Ï‰.1 (n + 1)) := by
  ext Ï‰
  rw [action, hist_add_one]
  simp only [add_le_iff_nonpos_right, nonpos_iff_eq_zero, one_ne_zero, â†“reduceDIte]

@[fun_prop]
lemma measurable_action [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    Measurable (action alg n) := by unfold action; fun_prop

noncomputable
def reward [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) (Ï‰ : probSpace Î± R) : R :=
  (hist alg Ï‰ n âŸ¨n, by simpâŸ©).2

lemma reward_zero [DecidableEq Î±] (alg : Algorithm Î± R) :
    reward alg 0 = fun Ï‰ â†¦ Ï‰.2 0 (action alg 0 Ï‰) := by
  ext
  simp [reward, hist_zero, action_zero]

lemma reward_eq [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    reward alg n = fun Ï‰ â†¦ Ï‰.2 (pullCount (action alg) (action alg n Ï‰) n Ï‰) (action alg n Ï‰) := by
  cases n with
  | zero => ext; simp [reward_zero, action_zero]
  | succ n =>
    ext Ï‰
    rw [reward, hist_add_one]
    simp only [add_le_iff_nonpos_right, nonpos_iff_eq_zero, one_ne_zero, â†“reduceDIte]
    rw [action_add_one_eq, pullCount_eq_pullCount' (R' := reward alg) (by simp)]
    simp only [Nat.add_one_sub_one]
    rw [hist_eq]
    rfl

@[fun_prop]
lemma measurable_reward [DecidableEq Î±] (alg : Algorithm Î± R) (n : â„•) :
    Measurable (reward alg n) := by unfold reward; fun_prop

variable [DecidableEq Î±]

lemma hasLaw_action_zero (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    HasLaw (action alg 0) alg.p0 (arrayMeasure Î½) where
  map_eq := by
    calc (arrayMeasure Î½).map (fun Ï‰ â†¦ initAlgFunction alg (Ï‰.1 0))
    _ = ((arrayMeasure Î½).fst.map (Function.eval 0)).map (initAlgFunction alg) := by
      rw [Measure.fst, Measure.map_map (by fun_prop) (by fun_prop),
        Measure.map_map (by fun_prop) (by fun_prop)]
      rfl
    _ = (volume : Measure I).map (initAlgFunction alg) := by
      simp only [arrayMeasure, Measure.fst_prod]
      rw [(measurePreserving_eval_infinitePi (fun _ â†¦ volume) 0).map_eq]
    _ = alg.p0 := initAlgFunction_map alg

variable [StandardBorelSpace R] [Nonempty R]

lemma hasCondDistrib_reward_zero [Countable Î±]
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    HasCondDistrib (reward alg 0) (action alg 0) (stationaryEnv Î½).Î½0 (arrayMeasure Î½) where
  condDistrib_eq := by
    -- simp only [stationaryEnv_Î½0]
    -- refine condDistrib_ae_eq_of_measure_eq_compProd _ (by fun_prop) ?_
    -- rw [reward_zero]
    -- simp only
    -- have : (fun x â†¦ (action alg 0 x, x.2 0 (action alg 0 x))) =
    --   (fun p â†¦ (p.2, p.1.2 0 p.2)) âˆ˜ (fun x â†¦ (x, action alg 0 x)) := rfl

    refine (condDistrib_ae_eq_cond (by fun_prop) (by fun_prop)).trans ?_
    rw [Filter.EventuallyEq, ae_iff_of_countable]
    intro a ha
    simp only [stationaryEnv_Î½0, reward_zero]
    calc ((arrayMeasure Î½)[|action alg 0 â»Â¹' {a}]).map (fun Ï‰ â†¦ Ï‰.2 0 (action alg 0 Ï‰))
    _ = ((arrayMeasure Î½)[|action alg 0 â»Â¹' {a}]).map (fun Ï‰ â†¦ Ï‰.2 0 a) := by
      refine Measure.map_congr
        (ae_cond_of_forall_mem ((measurableSet_singleton _).preimage (by fun_prop)) ?_)
      intro x hx
      simp only [Set.mem_preimage, Set.mem_singleton_iff] at hx
      simp [hx]
    _ = Î½ a := sorry

lemma hasLaw_and_hasCondDistrib (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (n : â„•) :
    HasLaw (hist alg Â· n) ((Bandit.trajMeasure alg Î½).map (fun Ï‰ (i : Iic n) â†¦ Ï‰ i))
        (arrayMeasure Î½) âˆ§
      HasCondDistrib (hist alg Â· (n + 1) âŸ¨n + 1, by simpâŸ©) (hist alg Â· n)
        (Bandit.stepKernel alg Î½ n) (arrayMeasure Î½) := by
  induction n with
  | zero => sorry
  | succ n hn =>
    have h1 : HasLaw (fun x â†¦ hist alg x (n + 1)) (Measure.map (fun Ï‰ i â†¦ Ï‰ â†‘i)
        (Bandit.trajMeasure alg Î½)) (arrayMeasure Î½) := by
      have h_law := HasLaw.prod_of_hasCondDistrib hn.1 hn.2
      sorry
    refine âŸ¨h1, ?_âŸ©
    sorry

lemma hasCondDistrib_altStep' (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (n : â„•) :
    HasCondDistrib (hist alg Â· (n + 1) âŸ¨n + 1, by simpâŸ©) (hist alg Â· n)
      (Bandit.stepKernel alg Î½ n) (arrayMeasure Î½) where
  condDistrib_eq := by
    simp only [Bandit.stepKernel, stepKernel, stationaryEnv_feedback]
    sorry

lemma hasCondDistrib_altStep (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (n : â„•) :
    HasCondDistrib (fun Ï‰ â†¦ (action alg (n + 1) Ï‰, reward alg (n + 1) Ï‰))
      (fun Ï‰ (i : Iic n) â†¦ (action alg i Ï‰, reward alg i Ï‰))
      (Bandit.stepKernel alg Î½ n) (arrayMeasure Î½) := by
  convert hasCondDistrib_altStep' alg Î½ n with Ï‰ i
  Â· simp only [action]
    rw [hist_eq _ _ n]
  Â· simp only [reward]
    rw [hist_eq _ _ n]

lemma hasCondDistrib_action (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] (n : â„•) :
    HasCondDistrib (action alg (n + 1))
      (fun Ï‰ (i : Iic n) â†¦ (action alg i Ï‰, reward alg i Ï‰))
      (alg.policy n) (arrayMeasure Î½) := by
  convert HasCondDistrib.fst (hasCondDistrib_altStep alg Î½ n)
  simp

lemma hasCondDistrib_reward (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½]
    (n : â„•) :
    HasCondDistrib (reward alg (n + 1))
      (fun Ï‰ â†¦ (fun (i : Iic n) â†¦ (action alg i Ï‰, reward alg i Ï‰), action alg (n + 1) Ï‰))
      ((stationaryEnv Î½).feedback n) (arrayMeasure Î½) := by
  simp only [stationaryEnv_feedback]
  sorry

lemma isAlgEnvSeq_arrayMeasure [Countable Î±]
    (alg : Algorithm Î± R) (Î½ : Kernel Î± R) [IsMarkovKernel Î½] :
    IsAlgEnvSeq (action alg) (reward alg) alg (stationaryEnv Î½) (arrayMeasure Î½) where
  hasLaw_action_zero := hasLaw_action_zero alg Î½
  hasCondDistrib_reward_zero := hasCondDistrib_reward_zero alg Î½
  hasCondDistrib_action := hasCondDistrib_action alg Î½
  hasCondDistrib_reward := hasCondDistrib_reward alg Î½

end ArrayModel

end MeasureSpace

end Bandits
